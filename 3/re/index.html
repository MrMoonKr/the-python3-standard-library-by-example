<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>re — Regular Expressions &mdash; PyMOTW 3</title>

    <link rel="stylesheet" href="../_static/pure-min.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/font-awesome/css/font-awesome.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pymotw.css" type="text/css">

    <link rel="shortcut icon" type="image/png" href="../_static/favicon.png">

    <link rel="alternate" type="application/atom+xml"
          title="Doug Hellmann"
          href="https://feeds.feedburner.com/DougHellmann" />
    <link rel="alternate" type="application/atom+xml"
          title="PyMOTW Updates"
          href="https://feeds.feedburner.com/PyMOTW" />

    <meta name="verify-v1" content="5saTcOa2HLac4V85yUg3SARfun1PqT5Upu7IR/6fpv4="/>

    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@pymotw" />
    <meta name="twitter:title" content="re — Regular Expressions" />
    <meta name="twitter:image" content="https://pymotw.com/3/_static/logo-large.png" />

  </head>
  <body>

    <div class="pure-menu pure-menu-open pure-menu-horizontal" id="site-menu">
      <a class="pure-menu-heading" href="../index.html"><img src="../_static/logo.png"> PyMOTW-3</a>

      <ul id="top-menu">
        <li class="pure-menu-selected"><a href="../py-modindex.html"><i class="fa fa-list fa-lg"></i> Module Index</a></li>
        <li class="pure-menu-selected"><a href="../genindex.html"><i class="fa fa-italic fa-lg"></i> Index</a></li>
        <li class="pure-menu-selected"><a class="sociallink" href="http://www.twitter.com/pymotw"
       title="Twitter">
      <i class="fa fa-twitter fa-lg"></i></a></a>
        <li class="pure-menu-selected"><a class="sociallink" href="https://feeds.feedburner.com/PyMOTW"
       title="Subscribe via RSS">
      <i class="fa fa-rss-square fa-lg"></i></a></li>
      </ul>

    </div>

    <div class="pure-menu pure-menu-open pure-menu-vertical" id="breadcrumbs-menu">
      
      <ul id="breadcrumbs">
        <li class="pure-menu-selected"><a href="../text.html"><i class="fa fa-arrow-circle-up"></i> Text</a></li>
      </ul>
    </div>

    <div class="pure-g-r" id="content-container">

      <div class="pure-u-3-4">
        <div class="content">
          
  <div class="section" id="module-re">
<span id="re-regular-expressions"></span><h1>re — Regular Expressions<a class="headerlink" href="#module-re" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Purpose:</th><td class="field-body">Searching within and changing text using formal patterns.</td>
</tr>
</tbody>
</table>
<p><em>Regular expressions</em> are text matching patterns described with a
formal syntax.  The patterns are interpreted as a set of instructions,
which are then executed with a string as input to produce a matching
subset or modified version of the original.  The term “regular
expressions” is frequently shortened to “regex” or “regexp” in
conversation.  Expressions can include literal text matching,
repetition, pattern composition, branching, and other sophisticated
rules.  A large number of parsing problems are easier to solve with a
regular expression than by creating a special-purpose lexer and
parser.</p>
<p>Regular expressions are typically used in applications that involve a
lot of text processing.  For example, they are commonly used as search
patterns in text editing programs used by developers, including vi,
emacs, and modern IDEs.  They are also an integral part of Unix
command-line utilities such as sed, grep, and awk.  Many programming
languages include support for regular expressions in the language
syntax (Perl, Ruby, Awk, and Tcl).  Other languages, such as C, C++,
and Python, support regular expressions through extension libraries.</p>
<p>Multiple open source implementations of regular expressions exist,
each sharing a common core syntax but with different extensions or
modifications to their advanced features.  The syntax used in Python’s
<code class="docutils literal notranslate"><span class="pre">re</span></code> module is based on the syntax used for regular expressions
in Perl, with a few Python-specific enhancements.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Although the formal definition of “regular expression” is limited
to expressions that describe regular languages, some of the
extensions supported by <code class="docutils literal notranslate"><span class="pre">re</span></code> go beyond describing regular
languages.  The term “regular expression” is used here in a more
general sense to mean any expression that can be evaluated by
Python’s <code class="docutils literal notranslate"><span class="pre">re</span></code> module.</p>
</div>
<div class="section" id="finding-patterns-in-text">
<h2>Finding Patterns in Text<a class="headerlink" href="#finding-patterns-in-text" title="Permalink to this headline">¶</a></h2>
<p>The most common use for <code class="docutils literal notranslate"><span class="pre">re</span></code> is to search for patterns in text.
The <code class="docutils literal notranslate"><span class="pre">search()</span></code> function takes the pattern and text to scan, and
returns a <code class="docutils literal notranslate"><span class="pre">Match</span></code> object when the pattern is found.  If the
pattern is not found, <code class="docutils literal notranslate"><span class="pre">search()</span></code> returns <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>Each <code class="docutils literal notranslate"><span class="pre">Match</span></code> object holds information about the nature of the
match, including the original input string, the regular expression
used, and the location within the original string where the pattern
occurs.</p>
<div class="literal-block-wrapper docutils container" id="id1">
<div class="code-block-caption"><span class="caption-text">re_simple_match.py</span><a class="headerlink" href="#id1" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="n">pattern</span> <span class="o">=</span> <span class="s1">&#39;this&#39;</span>
<span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;Does this text match the pattern?&#39;</span>

<span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Found &quot;</span><span class="si">{}</span><span class="s1">&quot;</span><span class="se">\n</span><span class="s1">in &quot;</span><span class="si">{}</span><span class="s1">&quot;</span><span class="se">\n</span><span class="s1">from </span><span class="si">{}</span><span class="s1"> to </span><span class="si">{}</span><span class="s1"> (&quot;</span><span class="si">{}</span><span class="s1">&quot;)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
    <span class="n">match</span><span class="o">.</span><span class="n">re</span><span class="o">.</span><span class="n">pattern</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">text</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">e</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">start()</span></code> and <code class="docutils literal notranslate"><span class="pre">end()</span></code> methods give the indexes into the
string showing where the text matched by the pattern occurs.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_simple_match.py

Found &quot;this&quot;
in &quot;Does this text match the pattern?&quot;
from 5 to 9 (&quot;this&quot;)
</pre></div>
</div>
</div>
<div class="section" id="compiling-expressions">
<h2>Compiling Expressions<a class="headerlink" href="#compiling-expressions" title="Permalink to this headline">¶</a></h2>
<p>Although <code class="docutils literal notranslate"><span class="pre">re</span></code> includes module-level functions for working with regular
expressions as text strings, it is more efficient to <em>compile</em> the
expressions a program uses frequently.  The <code class="docutils literal notranslate"><span class="pre">compile()</span></code> function
converts an expression string into a <code class="docutils literal notranslate"><span class="pre">RegexObject</span></code>.</p>
<div class="literal-block-wrapper docutils container" id="id2">
<div class="code-block-caption"><span class="caption-text">re_simple_compiled.py</span><a class="headerlink" href="#id2" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="c1"># Precompile the patterns</span>
<span class="n">regexes</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;this&#39;</span><span class="p">,</span> <span class="s1">&#39;that&#39;</span><span class="p">]</span>
<span class="p">]</span>
<span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;Does this text match the pattern?&#39;</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Text: </span><span class="si">{!r}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">text</span><span class="p">))</span>

<span class="k">for</span> <span class="n">regex</span> <span class="ow">in</span> <span class="n">regexes</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Seeking &quot;</span><span class="si">{}</span><span class="s1">&quot; -&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">regex</span><span class="o">.</span><span class="n">pattern</span><span class="p">),</span>
          <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">regex</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;match!&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;no match&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>The module-level functions maintain a cache of compiled expressions,
but the size of the cache is limited and using compiled expressions
directly avoids the overhead associated with cache lookup.  Another advantage of using
compiled expressions is that by precompiling all of the expressions
when the module is loaded, the compilation work is shifted to
application start time, instead of occurring at a point where the program may be
responding to a user action.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_simple_compiled.py

Text: &#39;Does this text match the pattern?&#39;

Seeking &quot;this&quot; -&gt; match!
Seeking &quot;that&quot; -&gt; no match
</pre></div>
</div>
</div>
<div class="section" id="multiple-matches">
<h2>Multiple Matches<a class="headerlink" href="#multiple-matches" title="Permalink to this headline">¶</a></h2>
<p>So far, the example patterns have all used <code class="docutils literal notranslate"><span class="pre">search()</span></code> to look for
single instances of literal text strings.  The <code class="docutils literal notranslate"><span class="pre">findall()</span></code>
function returns all of the substrings of the input that match the
pattern without overlapping.</p>
<div class="literal-block-wrapper docutils container" id="id3">
<div class="code-block-caption"><span class="caption-text">re_findall.py</span><a class="headerlink" href="#id3" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;abbaaabbbbaaaaa&#39;</span>

<span class="n">pattern</span> <span class="o">=</span> <span class="s1">&#39;ab&#39;</span>

<span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Found </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">match</span><span class="p">))</span>
</pre></div>
</div>
</div>
<p>This example input string includes two instances of <code class="docutils literal notranslate"><span class="pre">ab</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_findall.py

Found &#39;ab&#39;
Found &#39;ab&#39;
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">finditer()</span></code> function returns an iterator that produces <code class="docutils literal notranslate"><span class="pre">Match</span></code>
instances instead of the strings returned by <code class="docutils literal notranslate"><span class="pre">findall()</span></code>.</p>
<div class="literal-block-wrapper docutils container" id="id4">
<div class="code-block-caption"><span class="caption-text">re_finditer.py</span><a class="headerlink" href="#id4" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;abbaaabbbbaaaaa&#39;</span>

<span class="n">pattern</span> <span class="o">=</span> <span class="s1">&#39;ab&#39;</span>

<span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Found </span><span class="si">{!r}</span><span class="s1"> at </span><span class="si">{:d}</span><span class="s1">:</span><span class="si">{:d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">text</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">e</span><span class="p">],</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>
</pre></div>
</div>
</div>
<p>This example finds the same two occurrences of <code class="docutils literal notranslate"><span class="pre">ab</span></code>, and the
<code class="docutils literal notranslate"><span class="pre">Match</span></code> instance shows where they are found in the original input.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_finditer.py

Found &#39;ab&#39; at 0:2
Found &#39;ab&#39; at 5:7
</pre></div>
</div>
</div>
<div class="section" id="pattern-syntax">
<h2>Pattern Syntax<a class="headerlink" href="#pattern-syntax" title="Permalink to this headline">¶</a></h2>
<p>Regular expressions support more powerful patterns than simple literal
text strings.  Patterns can repeat, can be anchored to different
logical locations within the input, and can be expressed in compact
forms that do not require every literal character to be present in the
pattern.  All of these features are used by combining literal text
values with <em>meta-characters</em> that are part of the regular expression
pattern syntax implemented by <code class="docutils literal notranslate"><span class="pre">re</span></code>.</p>
<div class="literal-block-wrapper docutils container" id="id5">
<div class="code-block-caption"><span class="caption-text">re_test_patterns.py</span><a class="headerlink" href="#id5" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>


<span class="k">def</span> <span class="nf">test_patterns</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">patterns</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given source text and a list of patterns, look for</span>
<span class="sd">    matches for each pattern within the text and print</span>
<span class="sd">    them to stdout.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Look for each pattern in the text and print the results</span>
    <span class="k">for</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">desc</span> <span class="ow">in</span> <span class="n">patterns</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39; (</span><span class="si">{}</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">desc</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">text</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
            <span class="n">substr</span> <span class="o">=</span> <span class="n">text</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">e</span><span class="p">]</span>
            <span class="n">n_backslashes</span> <span class="o">=</span> <span class="n">text</span><span class="p">[:</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span> <span class="o">*</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="n">n_backslashes</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  </span><span class="si">{}</span><span class="s2">&#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">substr</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">()</span>
    <span class="k">return</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">test_patterns</span><span class="p">(</span><span class="s1">&#39;abbaaabbbbaaaaa&#39;</span><span class="p">,</span>
                  <span class="p">[(</span><span class="s1">&#39;ab&#39;</span><span class="p">,</span> <span class="s2">&quot;&#39;a&#39; followed by &#39;b&#39;&quot;</span><span class="p">),</span>
                   <span class="p">])</span>
</pre></div>
</div>
</div>
<p>The following examples will use <code class="docutils literal notranslate"><span class="pre">test_patterns()</span></code> to explore how
variations in patterns change the way they match the same input text.
The output shows the input text and the substring range from each
portion of the input that matches the pattern.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_test_patterns.py

&#39;ab&#39; (&#39;a&#39; followed by &#39;b&#39;)

  &#39;abbaaabbbbaaaaa&#39;
  &#39;ab&#39;
  .....&#39;ab&#39;
</pre></div>
</div>
<div class="section" id="repetition">
<h3>Repetition<a class="headerlink" href="#repetition" title="Permalink to this headline">¶</a></h3>
<p>There are five ways to express repetition in a pattern.  A pattern
followed by the meta-character <code class="docutils literal notranslate"><span class="pre">*</span></code> is repeated zero or more times
(allowing a pattern to repeat zero times means it does not need to
appear at all to match).  If the <code class="docutils literal notranslate"><span class="pre">*</span></code> is replaced with <code class="docutils literal notranslate"><span class="pre">+</span></code>, the pattern
must appear at least once.  Using <code class="docutils literal notranslate"><span class="pre">?</span></code> means the pattern appears zero
or one time.  For a specific number of occurrences, use <code class="docutils literal notranslate"><span class="pre">{m}</span></code> after
the pattern, where <code class="docutils literal notranslate"><span class="pre">m</span></code> is the number of times the pattern should
repeat.  Finally, to allow a variable but limited number of
repetitions, use <code class="docutils literal notranslate"><span class="pre">{m,n}</span></code>, where <code class="docutils literal notranslate"><span class="pre">m</span></code> is the minimum number of
repetitions and <code class="docutils literal notranslate"><span class="pre">n</span></code> is the maximum.  Leaving out <code class="docutils literal notranslate"><span class="pre">n</span></code> (<code class="docutils literal notranslate"><span class="pre">{m,}</span></code>)
means the value must appear at least <code class="docutils literal notranslate"><span class="pre">m</span></code> times, with no maximum.</p>
<div class="literal-block-wrapper docutils container" id="id6">
<div class="code-block-caption"><span class="caption-text">re_repetition.py</span><a class="headerlink" href="#id6" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">re_test_patterns</span> <span class="k">import</span> <span class="n">test_patterns</span>

<span class="n">test_patterns</span><span class="p">(</span>
    <span class="s1">&#39;abbaabbba&#39;</span><span class="p">,</span>
    <span class="p">[(</span><span class="s1">&#39;ab*&#39;</span><span class="p">,</span> <span class="s1">&#39;a followed by zero or more b&#39;</span><span class="p">),</span>
     <span class="p">(</span><span class="s1">&#39;ab+&#39;</span><span class="p">,</span> <span class="s1">&#39;a followed by one or more b&#39;</span><span class="p">),</span>
     <span class="p">(</span><span class="s1">&#39;ab?&#39;</span><span class="p">,</span> <span class="s1">&#39;a followed by zero or one b&#39;</span><span class="p">),</span>
     <span class="p">(</span><span class="s1">&#39;ab</span><span class="si">{3}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;a followed by three b&#39;</span><span class="p">),</span>
     <span class="p">(</span><span class="s1">&#39;ab{2,3}&#39;</span><span class="p">,</span> <span class="s1">&#39;a followed by two to three b&#39;</span><span class="p">)],</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<p>There are more matches for <code class="docutils literal notranslate"><span class="pre">ab*</span></code> and <code class="docutils literal notranslate"><span class="pre">ab?</span></code> than <code class="docutils literal notranslate"><span class="pre">ab+</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_repetition.py

&#39;ab*&#39; (a followed by zero or more b)

  &#39;abbaabbba&#39;
  &#39;abb&#39;
  ...&#39;a&#39;
  ....&#39;abbb&#39;
  ........&#39;a&#39;

&#39;ab+&#39; (a followed by one or more b)

  &#39;abbaabbba&#39;
  &#39;abb&#39;
  ....&#39;abbb&#39;

&#39;ab?&#39; (a followed by zero or one b)

  &#39;abbaabbba&#39;
  &#39;ab&#39;
  ...&#39;a&#39;
  ....&#39;ab&#39;
  ........&#39;a&#39;

&#39;ab{3}&#39; (a followed by three b)

  &#39;abbaabbba&#39;
  ....&#39;abbb&#39;

&#39;ab{2,3}&#39; (a followed by two to three b)

  &#39;abbaabbba&#39;
  &#39;abb&#39;
  ....&#39;abbb&#39;
</pre></div>
</div>
<p>When processing a repetition instruction, <code class="docutils literal notranslate"><span class="pre">re</span></code> will usually
consume as much of the input as possible while matching the pattern.
This so-called <em>greedy</em> behavior may result in fewer individual
matches, or the matches may include more of the input text than
intended.  Greediness can be turned off by following the repetition
instruction with <code class="docutils literal notranslate"><span class="pre">?</span></code>.</p>
<div class="literal-block-wrapper docutils container" id="id7">
<div class="code-block-caption"><span class="caption-text">re_repetition_non_greedy.py</span><a class="headerlink" href="#id7" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">re_test_patterns</span> <span class="k">import</span> <span class="n">test_patterns</span>

<span class="n">test_patterns</span><span class="p">(</span>
    <span class="s1">&#39;abbaabbba&#39;</span><span class="p">,</span>
    <span class="p">[(</span><span class="s1">&#39;ab*?&#39;</span><span class="p">,</span> <span class="s1">&#39;a followed by zero or more b&#39;</span><span class="p">),</span>
     <span class="p">(</span><span class="s1">&#39;ab+?&#39;</span><span class="p">,</span> <span class="s1">&#39;a followed by one or more b&#39;</span><span class="p">),</span>
     <span class="p">(</span><span class="s1">&#39;ab??&#39;</span><span class="p">,</span> <span class="s1">&#39;a followed by zero or one b&#39;</span><span class="p">),</span>
     <span class="p">(</span><span class="s1">&#39;ab</span><span class="si">{3}</span><span class="s1">?&#39;</span><span class="p">,</span> <span class="s1">&#39;a followed by three b&#39;</span><span class="p">),</span>
     <span class="p">(</span><span class="s1">&#39;ab{2,3}?&#39;</span><span class="p">,</span> <span class="s1">&#39;a followed by two to three b&#39;</span><span class="p">)],</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<p>Disabling greedy consumption of the input for any of the patterns
where zero occurrences of <code class="docutils literal notranslate"><span class="pre">b</span></code> are allowed means the matched substring
does not include any <code class="docutils literal notranslate"><span class="pre">b</span></code> characters.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_repetition_non_greedy.py

&#39;ab*?&#39; (a followed by zero or more b)

  &#39;abbaabbba&#39;
  &#39;a&#39;
  ...&#39;a&#39;
  ....&#39;a&#39;
  ........&#39;a&#39;

&#39;ab+?&#39; (a followed by one or more b)

  &#39;abbaabbba&#39;
  &#39;ab&#39;
  ....&#39;ab&#39;

&#39;ab??&#39; (a followed by zero or one b)

  &#39;abbaabbba&#39;
  &#39;a&#39;
  ...&#39;a&#39;
  ....&#39;a&#39;
  ........&#39;a&#39;

&#39;ab{3}?&#39; (a followed by three b)

  &#39;abbaabbba&#39;
  ....&#39;abbb&#39;

&#39;ab{2,3}?&#39; (a followed by two to three b)

  &#39;abbaabbba&#39;
  &#39;abb&#39;
  ....&#39;abb&#39;
</pre></div>
</div>
</div>
<div class="section" id="character-sets">
<h3>Character Sets<a class="headerlink" href="#character-sets" title="Permalink to this headline">¶</a></h3>
<p>A <em>character set</em> is a group of characters, any one of which can match
at that point in the pattern.  For example, <code class="docutils literal notranslate"><span class="pre">[ab]</span></code> would match
either <code class="docutils literal notranslate"><span class="pre">a</span></code> or <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
<div class="literal-block-wrapper docutils container" id="id8">
<div class="code-block-caption"><span class="caption-text">re_charset.py</span><a class="headerlink" href="#id8" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">re_test_patterns</span> <span class="k">import</span> <span class="n">test_patterns</span>

<span class="n">test_patterns</span><span class="p">(</span>
    <span class="s1">&#39;abbaabbba&#39;</span><span class="p">,</span>
    <span class="p">[(</span><span class="s1">&#39;[ab]&#39;</span><span class="p">,</span> <span class="s1">&#39;either a or b&#39;</span><span class="p">),</span>
     <span class="p">(</span><span class="s1">&#39;a[ab]+&#39;</span><span class="p">,</span> <span class="s1">&#39;a followed by 1 or more a or b&#39;</span><span class="p">),</span>
     <span class="p">(</span><span class="s1">&#39;a[ab]+?&#39;</span><span class="p">,</span> <span class="s1">&#39;a followed by 1 or more a or b, not greedy&#39;</span><span class="p">)],</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<p>The greedy form of the expression (<code class="docutils literal notranslate"><span class="pre">a[ab]+</span></code>) consumes the entire
string because the first letter is <code class="docutils literal notranslate"><span class="pre">a</span></code> and every subsequent
character is either <code class="docutils literal notranslate"><span class="pre">a</span></code> or <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_charset.py

&#39;[ab]&#39; (either a or b)

  &#39;abbaabbba&#39;
  &#39;a&#39;
  .&#39;b&#39;
  ..&#39;b&#39;
  ...&#39;a&#39;
  ....&#39;a&#39;
  .....&#39;b&#39;
  ......&#39;b&#39;
  .......&#39;b&#39;
  ........&#39;a&#39;

&#39;a[ab]+&#39; (a followed by 1 or more a or b)

  &#39;abbaabbba&#39;
  &#39;abbaabbba&#39;

&#39;a[ab]+?&#39; (a followed by 1 or more a or b, not greedy)

  &#39;abbaabbba&#39;
  &#39;ab&#39;
  ...&#39;aa&#39;
</pre></div>
</div>
<p>A character set can also be used to exclude specific characters.  The
carat (<code class="docutils literal notranslate"><span class="pre">^</span></code>) means to look for characters that are not in the set
following the carat.</p>
<div class="literal-block-wrapper docutils container" id="id9">
<div class="code-block-caption"><span class="caption-text">re_charset_exclude.py</span><a class="headerlink" href="#id9" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">re_test_patterns</span> <span class="k">import</span> <span class="n">test_patterns</span>

<span class="n">test_patterns</span><span class="p">(</span>
    <span class="s1">&#39;This is some text -- with punctuation.&#39;</span><span class="p">,</span>
    <span class="p">[(</span><span class="s1">&#39;[^-. ]+&#39;</span><span class="p">,</span> <span class="s1">&#39;sequences without -, ., or space&#39;</span><span class="p">)],</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<p>This pattern finds all of the substrings that do not contain the
characters <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">.</span></code>, or a space.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_charset_exclude.py

&#39;[^-. ]+&#39; (sequences without -, ., or space)

  &#39;This is some text -- with punctuation.&#39;
  &#39;This&#39;
  .....&#39;is&#39;
  ........&#39;some&#39;
  .............&#39;text&#39;
  .....................&#39;with&#39;
  ..........................&#39;punctuation&#39;
</pre></div>
</div>
<p>As character sets grow larger, typing every character that should (or
should not) match becomes tedious.  A more compact format using
<em>character ranges</em> can be used to define a character set to include
all of the contiguous characters between the specified start and stop
points.</p>
<div class="literal-block-wrapper docutils container" id="id10">
<div class="code-block-caption"><span class="caption-text">re_charset_ranges.py</span><a class="headerlink" href="#id10" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">re_test_patterns</span> <span class="k">import</span> <span class="n">test_patterns</span>

<span class="n">test_patterns</span><span class="p">(</span>
    <span class="s1">&#39;This is some text -- with punctuation.&#39;</span><span class="p">,</span>
    <span class="p">[(</span><span class="s1">&#39;[a-z]+&#39;</span><span class="p">,</span> <span class="s1">&#39;sequences of lowercase letters&#39;</span><span class="p">),</span>
     <span class="p">(</span><span class="s1">&#39;[A-Z]+&#39;</span><span class="p">,</span> <span class="s1">&#39;sequences of uppercase letters&#39;</span><span class="p">),</span>
     <span class="p">(</span><span class="s1">&#39;[a-zA-Z]+&#39;</span><span class="p">,</span> <span class="s1">&#39;sequences of letters of either case&#39;</span><span class="p">),</span>
     <span class="p">(</span><span class="s1">&#39;[A-Z][a-z]+&#39;</span><span class="p">,</span> <span class="s1">&#39;one uppercase followed by lowercase&#39;</span><span class="p">)],</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<p>Here the range <code class="docutils literal notranslate"><span class="pre">a-z</span></code> includes the lowercase ASCII letters, and the
range <code class="docutils literal notranslate"><span class="pre">A-Z</span></code> includes the uppercase ASCII letters.  The ranges can
also be combined into a single character set.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_charset_ranges.py

&#39;[a-z]+&#39; (sequences of lowercase letters)

  &#39;This is some text -- with punctuation.&#39;
  .&#39;his&#39;
  .....&#39;is&#39;
  ........&#39;some&#39;
  .............&#39;text&#39;
  .....................&#39;with&#39;
  ..........................&#39;punctuation&#39;

&#39;[A-Z]+&#39; (sequences of uppercase letters)

  &#39;This is some text -- with punctuation.&#39;
  &#39;T&#39;

&#39;[a-zA-Z]+&#39; (sequences of letters of either case)

  &#39;This is some text -- with punctuation.&#39;
  &#39;This&#39;
  .....&#39;is&#39;
  ........&#39;some&#39;
  .............&#39;text&#39;
  .....................&#39;with&#39;
  ..........................&#39;punctuation&#39;

&#39;[A-Z][a-z]+&#39; (one uppercase followed by lowercase)

  &#39;This is some text -- with punctuation.&#39;
  &#39;This&#39;
</pre></div>
</div>
<p>As a special case of a character set, the meta-character dot, or period
(<code class="docutils literal notranslate"><span class="pre">.</span></code>), indicates that the pattern should match any single character
in that position.</p>
<div class="literal-block-wrapper docutils container" id="id11">
<div class="code-block-caption"><span class="caption-text">re_charset_dot.py</span><a class="headerlink" href="#id11" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">re_test_patterns</span> <span class="k">import</span> <span class="n">test_patterns</span>

<span class="n">test_patterns</span><span class="p">(</span>
    <span class="s1">&#39;abbaabbba&#39;</span><span class="p">,</span>
    <span class="p">[(</span><span class="s1">&#39;a.&#39;</span><span class="p">,</span> <span class="s1">&#39;a followed by any one character&#39;</span><span class="p">),</span>
     <span class="p">(</span><span class="s1">&#39;b.&#39;</span><span class="p">,</span> <span class="s1">&#39;b followed by any one character&#39;</span><span class="p">),</span>
     <span class="p">(</span><span class="s1">&#39;a.*b&#39;</span><span class="p">,</span> <span class="s1">&#39;a followed by anything, ending in b&#39;</span><span class="p">),</span>
     <span class="p">(</span><span class="s1">&#39;a.*?b&#39;</span><span class="p">,</span> <span class="s1">&#39;a followed by anything, ending in b&#39;</span><span class="p">)],</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<p>Combining the dot with repetition can result in very long matches, unless
the non-greedy form is used.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_charset_dot.py

&#39;a.&#39; (a followed by any one character)

  &#39;abbaabbba&#39;
  &#39;ab&#39;
  ...&#39;aa&#39;

&#39;b.&#39; (b followed by any one character)

  &#39;abbaabbba&#39;
  .&#39;bb&#39;
  .....&#39;bb&#39;
  .......&#39;ba&#39;

&#39;a.*b&#39; (a followed by anything, ending in b)

  &#39;abbaabbba&#39;
  &#39;abbaabbb&#39;

&#39;a.*?b&#39; (a followed by anything, ending in b)

  &#39;abbaabbba&#39;
  &#39;ab&#39;
  ...&#39;aab&#39;
</pre></div>
</div>
</div>
<div class="section" id="escape-codes">
<h3>Escape Codes<a class="headerlink" href="#escape-codes" title="Permalink to this headline">¶</a></h3>
<p>An even more compact representation uses escape codes for several
predefined character sets.  The escape codes recognized by <code class="docutils literal notranslate"><span class="pre">re</span></code>
are listed in the table below.</p>
<table border="1" class="docutils" id="id12">
<caption><span class="caption-text">Regular Expression Escape Codes</span><a class="headerlink" href="#id12" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="14%" />
<col width="86%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Code</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">\d</span></code></td>
<td>a digit</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">\D</span></code></td>
<td>a non-digit</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">\s</span></code></td>
<td>whitespace (tab, space, newline, etc.)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">\S</span></code></td>
<td>non-whitespace</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">\w</span></code></td>
<td>alphanumeric</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">\W</span></code></td>
<td>non-alphanumeric</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Escapes are indicated by prefixing the character with a backslash
(<code class="docutils literal notranslate"><span class="pre">\</span></code>). Unfortunately, a backslash must itself be escaped in normal
Python strings, and that results in difficult-to-read expressions.
Using <em>raw</em> strings, which are created by prefixing the literal
value with <code class="docutils literal notranslate"><span class="pre">r</span></code>, eliminates this problem and maintains readability.</p>
</div>
<div class="literal-block-wrapper docutils container" id="id13">
<div class="code-block-caption"><span class="caption-text">re_escape_codes.py</span><a class="headerlink" href="#id13" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">re_test_patterns</span> <span class="k">import</span> <span class="n">test_patterns</span>

<span class="n">test_patterns</span><span class="p">(</span>
    <span class="s1">&#39;A prime #1 example!&#39;</span><span class="p">,</span>
    <span class="p">[(</span><span class="sa">r</span><span class="s1">&#39;\d+&#39;</span><span class="p">,</span> <span class="s1">&#39;sequence of digits&#39;</span><span class="p">),</span>
     <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\D+&#39;</span><span class="p">,</span> <span class="s1">&#39;sequence of non-digits&#39;</span><span class="p">),</span>
     <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\s+&#39;</span><span class="p">,</span> <span class="s1">&#39;sequence of whitespace&#39;</span><span class="p">),</span>
     <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\S+&#39;</span><span class="p">,</span> <span class="s1">&#39;sequence of non-whitespace&#39;</span><span class="p">),</span>
     <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\w+&#39;</span><span class="p">,</span> <span class="s1">&#39;alphanumeric characters&#39;</span><span class="p">),</span>
     <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\W+&#39;</span><span class="p">,</span> <span class="s1">&#39;non-alphanumeric&#39;</span><span class="p">)],</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<p>These sample expressions combine escape codes with repetition to find
sequences of like characters in the input string.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_escape_codes.py

&#39;\d+&#39; (sequence of digits)

  &#39;A prime #1 example!&#39;
  .........&#39;1&#39;

&#39;\D+&#39; (sequence of non-digits)

  &#39;A prime #1 example!&#39;
  &#39;A prime #&#39;
  ..........&#39; example!&#39;

&#39;\s+&#39; (sequence of whitespace)

  &#39;A prime #1 example!&#39;
  .&#39; &#39;
  .......&#39; &#39;
  ..........&#39; &#39;

&#39;\S+&#39; (sequence of non-whitespace)

  &#39;A prime #1 example!&#39;
  &#39;A&#39;
  ..&#39;prime&#39;
  ........&#39;#1&#39;
  ...........&#39;example!&#39;

&#39;\w+&#39; (alphanumeric characters)

  &#39;A prime #1 example!&#39;
  &#39;A&#39;
  ..&#39;prime&#39;
  .........&#39;1&#39;
  ...........&#39;example&#39;

&#39;\W+&#39; (non-alphanumeric)

  &#39;A prime #1 example!&#39;
  .&#39; &#39;
  .......&#39; #&#39;
  ..........&#39; &#39;
  ..................&#39;!&#39;
</pre></div>
</div>
<p>To match the characters that are part of the regular expression
syntax, escape the characters in the search pattern.</p>
<div class="literal-block-wrapper docutils container" id="id14">
<div class="code-block-caption"><span class="caption-text">re_escape_escapes.py</span><a class="headerlink" href="#id14" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">re_test_patterns</span> <span class="k">import</span> <span class="n">test_patterns</span>

<span class="n">test_patterns</span><span class="p">(</span>
    <span class="sa">r</span><span class="s1">&#39;\d+ \D+ \s+&#39;</span><span class="p">,</span>
    <span class="p">[(</span><span class="sa">r</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">.\+&#39;</span><span class="p">,</span> <span class="s1">&#39;escape code&#39;</span><span class="p">)],</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<p>The pattern in this example escapes the backslash and plus characters,
since both are meta-characters and have special meaning in a regular
expression.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_escape_escapes.py

&#39;\\.\+&#39; (escape code)

  &#39;\d+ \D+ \s+&#39;
  &#39;\d+&#39;
  .....&#39;\D+&#39;
  ..........&#39;\s+&#39;
</pre></div>
</div>
</div>
<div class="section" id="anchoring">
<h3>Anchoring<a class="headerlink" href="#anchoring" title="Permalink to this headline">¶</a></h3>
<p>In addition to describing the content of a pattern to match, the
relative location can be specified in the input text where the pattern
should appear by using <em>anchoring</em> instructions.  the table below lists valid anchoring codes.</p>
<table border="1" class="docutils" id="id15">
<caption><span class="caption-text">Regular Expression Anchoring Codes</span><a class="headerlink" href="#id15" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="11%" />
<col width="89%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Code</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">^</span></code></td>
<td>start of string, or line</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">$</span></code></td>
<td>end of string, or line</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">\A</span></code></td>
<td>start of string</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">\Z</span></code></td>
<td>end of string</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">\b</span></code></td>
<td>empty string at the beginning or end of a word</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">\B</span></code></td>
<td>empty string not at the beginning or end of a word</td>
</tr>
</tbody>
</table>
<div class="literal-block-wrapper docutils container" id="id16">
<div class="code-block-caption"><span class="caption-text">re_anchoring.py</span><a class="headerlink" href="#id16" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">re_test_patterns</span> <span class="k">import</span> <span class="n">test_patterns</span>

<span class="n">test_patterns</span><span class="p">(</span>
    <span class="s1">&#39;This is some text -- with punctuation.&#39;</span><span class="p">,</span>
    <span class="p">[(</span><span class="sa">r</span><span class="s1">&#39;^\w+&#39;</span><span class="p">,</span> <span class="s1">&#39;word at start of string&#39;</span><span class="p">),</span>
     <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\A\w+&#39;</span><span class="p">,</span> <span class="s1">&#39;word at start of string&#39;</span><span class="p">),</span>
     <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\w+\S*$&#39;</span><span class="p">,</span> <span class="s1">&#39;word near end of string&#39;</span><span class="p">),</span>
     <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\w+\S*\Z&#39;</span><span class="p">,</span> <span class="s1">&#39;word near end of string&#39;</span><span class="p">),</span>
     <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\w*t\w*&#39;</span><span class="p">,</span> <span class="s1">&#39;word containing t&#39;</span><span class="p">),</span>
     <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\bt\w+&#39;</span><span class="p">,</span> <span class="s1">&#39;t at start of word&#39;</span><span class="p">),</span>
     <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\w+t\b&#39;</span><span class="p">,</span> <span class="s1">&#39;t at end of word&#39;</span><span class="p">),</span>
     <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\Bt\B&#39;</span><span class="p">,</span> <span class="s1">&#39;t, not start or end of word&#39;</span><span class="p">)],</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<p>The patterns in the example for matching words at the beginning and the
end of the string are different because the word at the end of the
string is followed by punctuation to terminate the sentence.  The
pattern <code class="docutils literal notranslate"><span class="pre">\w+$</span></code> would not match, since <code class="docutils literal notranslate"><span class="pre">.</span></code> is not considered an
alphanumeric character.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_anchoring.py

&#39;^\w+&#39; (word at start of string)

  &#39;This is some text -- with punctuation.&#39;
  &#39;This&#39;

&#39;\A\w+&#39; (word at start of string)

  &#39;This is some text -- with punctuation.&#39;
  &#39;This&#39;

&#39;\w+\S*$&#39; (word near end of string)

  &#39;This is some text -- with punctuation.&#39;
  ..........................&#39;punctuation.&#39;

&#39;\w+\S*\Z&#39; (word near end of string)

  &#39;This is some text -- with punctuation.&#39;
  ..........................&#39;punctuation.&#39;

&#39;\w*t\w*&#39; (word containing t)

  &#39;This is some text -- with punctuation.&#39;
  .............&#39;text&#39;
  .....................&#39;with&#39;
  ..........................&#39;punctuation&#39;

&#39;\bt\w+&#39; (t at start of word)

  &#39;This is some text -- with punctuation.&#39;
  .............&#39;text&#39;

&#39;\w+t\b&#39; (t at end of word)

  &#39;This is some text -- with punctuation.&#39;
  .............&#39;text&#39;

&#39;\Bt\B&#39; (t, not start or end of word)

  &#39;This is some text -- with punctuation.&#39;
  .......................&#39;t&#39;
  ..............................&#39;t&#39;
  .................................&#39;t&#39;
</pre></div>
</div>
</div>
</div>
<div class="section" id="constraining-the-search">
<h2>Constraining the Search<a class="headerlink" href="#constraining-the-search" title="Permalink to this headline">¶</a></h2>
<p>In situations where it is known in advance that only a subset of the
full input should be searched, the regular expression match can be
further constrained by telling <code class="docutils literal notranslate"><span class="pre">re</span></code> to limit the search range.
For example, if the pattern must appear at the front of the input,
then using <code class="docutils literal notranslate"><span class="pre">match()</span></code> instead of <code class="docutils literal notranslate"><span class="pre">search()</span></code> will anchor the
search without having to explicitly include an anchor in the search
pattern.</p>
<div class="literal-block-wrapper docutils container" id="id17">
<div class="code-block-caption"><span class="caption-text">re_match.py</span><a class="headerlink" href="#id17" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;This is some text -- with punctuation.&#39;</span>
<span class="n">pattern</span> <span class="o">=</span> <span class="s1">&#39;is&#39;</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Text   :&#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Pattern:&#39;</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Match  :&#39;</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Search :&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>Since the literal text <code class="docutils literal notranslate"><span class="pre">is</span></code> does not appear at the start of the
input text, it is not found using <code class="docutils literal notranslate"><span class="pre">match()</span></code>.  The sequence appears
two other times in the text, though, so <code class="docutils literal notranslate"><span class="pre">search()</span></code> finds it.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_match.py

Text   : This is some text -- with punctuation.
Pattern: is
Match  : None
Search : &lt;re.Match object; span=(2, 4), match=&#39;is&#39;&gt;
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">fullmatch()</span></code> method requires that the entire input string
match the pattern.</p>
<div class="literal-block-wrapper docutils container" id="id18">
<div class="code-block-caption"><span class="caption-text">re_fullmatch.py</span><a class="headerlink" href="#id18" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;This is some text -- with punctuation.&#39;</span>
<span class="n">pattern</span> <span class="o">=</span> <span class="s1">&#39;is&#39;</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Text       :&#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Pattern    :&#39;</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Search     :&#39;</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Full match :&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">search()</span></code> shows that the pattern does appear in the input,
but it does not consume all of the input so <code class="docutils literal notranslate"><span class="pre">fullmatch()</span></code> does not
report a match.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_fullmatch.py

Text       : This is some text -- with punctuation.
Pattern    : is
Search     : &lt;re.Match object; span=(2, 4), match=&#39;is&#39;&gt;
Full match : None
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">search()</span></code> method of a compiled regular expression accepts
optional <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">end</span></code> position parameters to limit the search
to a substring of the input.</p>
<div class="literal-block-wrapper docutils container" id="id19">
<div class="code-block-caption"><span class="caption-text">re_search_substring.py</span><a class="headerlink" href="#id19" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;This is some text -- with punctuation.&#39;</span>
<span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\b\w*is\w*\b&#39;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Text:&#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="nb">print</span><span class="p">()</span>

<span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">match</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  </span><span class="si">{:&gt;2d}</span><span class="s1"> : </span><span class="si">{:&gt;2d}</span><span class="s1"> = &quot;</span><span class="si">{}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">s</span><span class="p">,</span> <span class="n">e</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">text</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">e</span><span class="p">]))</span>
    <span class="c1"># Move forward in text for the next search</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">e</span>
</pre></div>
</div>
</div>
<p>This example implements a less efficient form of <code class="docutils literal notranslate"><span class="pre">iterall()</span></code>.
Each time a match is found, the end position of that match is used for
the next search.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_search_substring.py

Text: This is some text -- with punctuation.

   0 :  3 = &quot;This&quot;
   5 :  6 = &quot;is&quot;
</pre></div>
</div>
</div>
<div class="section" id="dissecting-matches-with-groups">
<h2>Dissecting Matches with Groups<a class="headerlink" href="#dissecting-matches-with-groups" title="Permalink to this headline">¶</a></h2>
<p>Searching for pattern matches is the basis of the powerful
capabilities provided by regular expressions.  Adding <em>groups</em> to a
pattern isolates parts of the matching text, expanding those
capabilities to create a parser.  Groups are defined by enclosing
patterns in parentheses.</p>
<div class="literal-block-wrapper docutils container" id="id20">
<div class="code-block-caption"><span class="caption-text">re_groups.py</span><a class="headerlink" href="#id20" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">re_test_patterns</span> <span class="k">import</span> <span class="n">test_patterns</span>

<span class="n">test_patterns</span><span class="p">(</span>
    <span class="s1">&#39;abbaaabbbbaaaaa&#39;</span><span class="p">,</span>
    <span class="p">[(</span><span class="s1">&#39;a(ab)&#39;</span><span class="p">,</span> <span class="s1">&#39;a followed by literal ab&#39;</span><span class="p">),</span>
     <span class="p">(</span><span class="s1">&#39;a(a*b*)&#39;</span><span class="p">,</span> <span class="s1">&#39;a followed by 0-n a and 0-n b&#39;</span><span class="p">),</span>
     <span class="p">(</span><span class="s1">&#39;a(ab)*&#39;</span><span class="p">,</span> <span class="s1">&#39;a followed by 0-n ab&#39;</span><span class="p">),</span>
     <span class="p">(</span><span class="s1">&#39;a(ab)+&#39;</span><span class="p">,</span> <span class="s1">&#39;a followed by 1-n ab&#39;</span><span class="p">)],</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<p>Any complete regular expression can be converted to a group and nested
within a larger expression.  All of the repetition modifiers can be
applied to a group as a whole, requiring the entire group pattern to
repeat.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_groups.py

&#39;a(ab)&#39; (a followed by literal ab)

  &#39;abbaaabbbbaaaaa&#39;
  ....&#39;aab&#39;

&#39;a(a*b*)&#39; (a followed by 0-n a and 0-n b)

  &#39;abbaaabbbbaaaaa&#39;
  &#39;abb&#39;
  ...&#39;aaabbbb&#39;
  ..........&#39;aaaaa&#39;

&#39;a(ab)*&#39; (a followed by 0-n ab)

  &#39;abbaaabbbbaaaaa&#39;
  &#39;a&#39;
  ...&#39;a&#39;
  ....&#39;aab&#39;
  ..........&#39;a&#39;
  ...........&#39;a&#39;
  ............&#39;a&#39;
  .............&#39;a&#39;
  ..............&#39;a&#39;

&#39;a(ab)+&#39; (a followed by 1-n ab)

  &#39;abbaaabbbbaaaaa&#39;
  ....&#39;aab&#39;
</pre></div>
</div>
<p>To access the substrings matched by the individual groups within a
pattern, use the <code class="docutils literal notranslate"><span class="pre">groups()</span></code> method of the <code class="docutils literal notranslate"><span class="pre">Match</span></code> object.</p>
<div class="literal-block-wrapper docutils container" id="id21">
<div class="code-block-caption"><span class="caption-text">re_groups_match.py</span><a class="headerlink" href="#id21" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;This is some text -- with punctuation.&#39;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
<span class="nb">print</span><span class="p">()</span>

<span class="n">patterns</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^(\w+)&#39;</span><span class="p">,</span> <span class="s1">&#39;word at start of string&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\w+)\S*$&#39;</span><span class="p">,</span> <span class="s1">&#39;word at end, with optional punctuation&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\bt\w+)\W+(\w+)&#39;</span><span class="p">,</span> <span class="s1">&#39;word starting with t, another word&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\w+t)\b&#39;</span><span class="p">,</span> <span class="s1">&#39;word ending with t&#39;</span><span class="p">),</span>
<span class="p">]</span>

<span class="k">for</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">desc</span> <span class="ow">in</span> <span class="n">patterns</span><span class="p">:</span>
    <span class="n">regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
    <span class="n">match</span> <span class="o">=</span> <span class="n">regex</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39; (</span><span class="si">{}</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">desc</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  &#39;</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">groups</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Match.groups()</span></code> returns a sequence of strings in the order of the
groups within the expression that matches the string.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_groups_match.py

This is some text -- with punctuation.

&#39;^(\w+)&#39; (word at start of string)

   (&#39;This&#39;,)

&#39;(\w+)\S*$&#39; (word at end, with optional punctuation)

   (&#39;punctuation&#39;,)

&#39;(\bt\w+)\W+(\w+)&#39; (word starting with t, another word)

   (&#39;text&#39;, &#39;with&#39;)

&#39;(\w+t)\b&#39; (word ending with t)

   (&#39;text&#39;,)
</pre></div>
</div>
<p>To ask for the match of a single group, use the <code class="docutils literal notranslate"><span class="pre">group()</span></code> method.  This is
useful when grouping is being used to find parts of the string, but
some of the parts matched by groups are not needed in the results.</p>
<div class="literal-block-wrapper docutils container" id="id22">
<div class="code-block-caption"><span class="caption-text">re_groups_individual.py</span><a class="headerlink" href="#id22" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;This is some text -- with punctuation.&#39;</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Input text            :&#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>

<span class="c1"># word starting with &#39;t&#39; then another word</span>
<span class="n">regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\bt\w+)\W+(\w+)&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Pattern               :&#39;</span><span class="p">,</span> <span class="n">regex</span><span class="o">.</span><span class="n">pattern</span><span class="p">)</span>

<span class="n">match</span> <span class="o">=</span> <span class="n">regex</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Entire match          :&#39;</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Word starting with &quot;t&quot;:&#39;</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Word after &quot;t&quot; word   :&#39;</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
</div>
<p>Group <code class="docutils literal notranslate"><span class="pre">0</span></code> represents the string matched by the entire expression,
and subgroups are numbered starting with <code class="docutils literal notranslate"><span class="pre">1</span></code> in the order that their
left parenthesis appears in the expression.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_groups_individual.py

Input text            : This is some text -- with punctuation.
Pattern               : (\bt\w+)\W+(\w+)
Entire match          : text -- with
Word starting with &quot;t&quot;: text
Word after &quot;t&quot; word   : with
</pre></div>
</div>
<p>Python extends the basic grouping syntax to add <em>named groups</em>.  Using
names to refer to groups makes it easier to modify the pattern over
time, without having to also modify the code using the match results.
To set the name of a group, use the syntax <code class="docutils literal notranslate"><span class="pre">(?P&lt;name&gt;pattern)</span></code>.</p>
<div class="literal-block-wrapper docutils container" id="id23">
<div class="code-block-caption"><span class="caption-text">re_groups_named.py</span><a class="headerlink" href="#id23" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;This is some text -- with punctuation.&#39;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
<span class="nb">print</span><span class="p">()</span>

<span class="n">patterns</span> <span class="o">=</span> <span class="p">[</span>
    <span class="sa">r</span><span class="s1">&#39;^(?P&lt;first_word&gt;\w+)&#39;</span><span class="p">,</span>
    <span class="sa">r</span><span class="s1">&#39;(?P&lt;last_word&gt;\w+)\S*$&#39;</span><span class="p">,</span>
    <span class="sa">r</span><span class="s1">&#39;(?P&lt;t_word&gt;\bt\w+)\W+(?P&lt;other_word&gt;\w+)&#39;</span><span class="p">,</span>
    <span class="sa">r</span><span class="s1">&#39;(?P&lt;ends_with_t&gt;\w+t)\b&#39;</span><span class="p">,</span>
<span class="p">]</span>

<span class="k">for</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">patterns</span><span class="p">:</span>
    <span class="n">regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
    <span class="n">match</span> <span class="o">=</span> <span class="n">regex</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pattern</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  &#39;</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">groups</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  &#39;</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">groupdict</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>
</div>
</div>
<p>Use <code class="docutils literal notranslate"><span class="pre">groupdict()</span></code> to retrieve the dictionary mapping group names
to substrings from the match.  Named patterns are included in the
ordered sequence returned by <code class="docutils literal notranslate"><span class="pre">groups()</span></code> as well.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_groups_named.py

This is some text -- with punctuation.

&#39;^(?P&lt;first_word&gt;\w+)&#39;
   (&#39;This&#39;,)
   {&#39;first_word&#39;: &#39;This&#39;}

&#39;(?P&lt;last_word&gt;\w+)\S*$&#39;
   (&#39;punctuation&#39;,)
   {&#39;last_word&#39;: &#39;punctuation&#39;}

&#39;(?P&lt;t_word&gt;\bt\w+)\W+(?P&lt;other_word&gt;\w+)&#39;
   (&#39;text&#39;, &#39;with&#39;)
   {&#39;t_word&#39;: &#39;text&#39;, &#39;other_word&#39;: &#39;with&#39;}

&#39;(?P&lt;ends_with_t&gt;\w+t)\b&#39;
   (&#39;text&#39;,)
   {&#39;ends_with_t&#39;: &#39;text&#39;}
</pre></div>
</div>
<p>An updated version of <code class="docutils literal notranslate"><span class="pre">test_patterns()</span></code> that shows the numbered
and named groups matched by a pattern will make the following examples
easier to follow.</p>
<div class="literal-block-wrapper docutils container" id="id24">
<div class="code-block-caption"><span class="caption-text">re_test_patterns_groups.py</span><a class="headerlink" href="#id24" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>


<span class="k">def</span> <span class="nf">test_patterns</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">patterns</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given source text and a list of patterns, look for</span>
<span class="sd">    matches for each pattern within the text and print</span>
<span class="sd">    them to stdout.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Look for each pattern in the text and print the results</span>
    <span class="k">for</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">desc</span> <span class="ow">in</span> <span class="n">patterns</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{!r}</span><span class="s1"> (</span><span class="si">{}</span><span class="s1">)</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">desc</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">text</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s1">&#39;  </span><span class="si">{}{!r}{}</span><span class="s1"> &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span>
                                     <span class="n">text</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">e</span><span class="p">],</span>
                                     <span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">-</span> <span class="n">e</span><span class="p">)),</span>
                <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">groups</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">match</span><span class="o">.</span><span class="n">groupdict</span><span class="p">():</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">-</span> <span class="n">s</span><span class="p">),</span>
                    <span class="n">match</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()),</span>
                <span class="p">)</span>
        <span class="nb">print</span><span class="p">()</span>
    <span class="k">return</span>
</pre></div>
</div>
</div>
<p>Since a group is itself a complete regular expression, groups can be
nested within other groups to build even more complicated expressions.</p>
<div class="literal-block-wrapper docutils container" id="id25">
<div class="code-block-caption"><span class="caption-text">re_groups_nested.py</span><a class="headerlink" href="#id25" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">re_test_patterns_groups</span> <span class="k">import</span> <span class="n">test_patterns</span>

<span class="n">test_patterns</span><span class="p">(</span>
    <span class="s1">&#39;abbaabbba&#39;</span><span class="p">,</span>
    <span class="p">[(</span><span class="sa">r</span><span class="s1">&#39;a((a*)(b*))&#39;</span><span class="p">,</span> <span class="s1">&#39;a followed by 0-n a and 0-n b&#39;</span><span class="p">)],</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<p>In this case, the group <code class="docutils literal notranslate"><span class="pre">(a*)</span></code> matches an empty string, so the
return value from <code class="docutils literal notranslate"><span class="pre">groups()</span></code> includes that empty string as the
matched value.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_groups_nested.py

&#39;a((a*)(b*))&#39; (a followed by 0-n a and 0-n b)

  &#39;abbaabbba&#39;
  &#39;abb&#39;        (&#39;bb&#39;, &#39;&#39;, &#39;bb&#39;)
     &#39;aabbb&#39;   (&#39;abbb&#39;, &#39;a&#39;, &#39;bbb&#39;)
          &#39;a&#39;  (&#39;&#39;, &#39;&#39;, &#39;&#39;)
</pre></div>
</div>
<p>Groups are also useful for specifying alternative patterns.  Use the
pipe symbol (<code class="docutils literal notranslate"><span class="pre">|</span></code>) to separate two patterns and indicate that either pattern should
match.  Consider the placement of the pipe carefully, though.  The
first expression in this example matches a sequence of <code class="docutils literal notranslate"><span class="pre">a</span></code> followed
by a sequence consisting entirely of a single letter, <code class="docutils literal notranslate"><span class="pre">a</span></code> or <code class="docutils literal notranslate"><span class="pre">b</span></code>.
The second pattern matches <code class="docutils literal notranslate"><span class="pre">a</span></code> followed by a sequence that may
include <em>either</em> <code class="docutils literal notranslate"><span class="pre">a</span></code> or <code class="docutils literal notranslate"><span class="pre">b</span></code>.  The patterns are similar, but the
resulting matches are completely different.</p>
<div class="literal-block-wrapper docutils container" id="id26">
<div class="code-block-caption"><span class="caption-text">re_groups_alternative.py</span><a class="headerlink" href="#id26" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">re_test_patterns_groups</span> <span class="k">import</span> <span class="n">test_patterns</span>

<span class="n">test_patterns</span><span class="p">(</span>
    <span class="s1">&#39;abbaabbba&#39;</span><span class="p">,</span>
    <span class="p">[(</span><span class="sa">r</span><span class="s1">&#39;a((a+)|(b+))&#39;</span><span class="p">,</span> <span class="s1">&#39;a then seq. of a or seq. of b&#39;</span><span class="p">),</span>
     <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;a((a|b)+)&#39;</span><span class="p">,</span> <span class="s1">&#39;a then seq. of [ab]&#39;</span><span class="p">)],</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<p>When an alternative group is not matched, but the entire pattern does
match, the return value of <code class="docutils literal notranslate"><span class="pre">groups()</span></code> includes a <code class="docutils literal notranslate"><span class="pre">None</span></code> value at
the point in the sequence where the alternative group should appear.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_groups_alternative.py

&#39;a((a+)|(b+))&#39; (a then seq. of a or seq. of b)

  &#39;abbaabbba&#39;
  &#39;abb&#39;        (&#39;bb&#39;, None, &#39;bb&#39;)
     &#39;aa&#39;      (&#39;a&#39;, &#39;a&#39;, None)

&#39;a((a|b)+)&#39; (a then seq. of [ab])

  &#39;abbaabbba&#39;
  &#39;abbaabbba&#39;  (&#39;bbaabbba&#39;, &#39;a&#39;)
</pre></div>
</div>
<p>Defining a group containing a subpattern is also useful in cases
where the string matching the subpattern is not part of what should
be extracted from the full text.  These kinds of groups are called
<em>non-capturing</em>.  Non-capturing groups can be used to describe
repetition patterns or alternatives, without isolating the matching
portion of the string in the value returned.  To create a
non-capturing group, use the syntax <code class="docutils literal notranslate"><span class="pre">(?:pattern)</span></code>.</p>
<div class="literal-block-wrapper docutils container" id="id27">
<div class="code-block-caption"><span class="caption-text">re_groups_noncapturing.py</span><a class="headerlink" href="#id27" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">re_test_patterns_groups</span> <span class="k">import</span> <span class="n">test_patterns</span>

<span class="n">test_patterns</span><span class="p">(</span>
    <span class="s1">&#39;abbaabbba&#39;</span><span class="p">,</span>
    <span class="p">[(</span><span class="sa">r</span><span class="s1">&#39;a((a+)|(b+))&#39;</span><span class="p">,</span> <span class="s1">&#39;capturing form&#39;</span><span class="p">),</span>
     <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;a((?:a+)|(?:b+))&#39;</span><span class="p">,</span> <span class="s1">&#39;noncapturing&#39;</span><span class="p">)],</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<p>In the following example, compare the groups returned for the capturing and non-capturing forms
of a pattern that matches the same results.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_groups_noncapturing.py

&#39;a((a+)|(b+))&#39; (capturing form)

  &#39;abbaabbba&#39;
  &#39;abb&#39;        (&#39;bb&#39;, None, &#39;bb&#39;)
     &#39;aa&#39;      (&#39;a&#39;, &#39;a&#39;, None)

&#39;a((?:a+)|(?:b+))&#39; (noncapturing)

  &#39;abbaabbba&#39;
  &#39;abb&#39;        (&#39;bb&#39;,)
     &#39;aa&#39;      (&#39;a&#39;,)
</pre></div>
</div>
</div>
<div class="section" id="search-options">
<h2>Search Options<a class="headerlink" href="#search-options" title="Permalink to this headline">¶</a></h2>
<p>Option flags are used to change the way the matching engine processes
an expression.  The flags can be combined using a bitwise OR
operation, then passed to <code class="docutils literal notranslate"><span class="pre">compile()</span></code>, <code class="docutils literal notranslate"><span class="pre">search()</span></code>, <code class="docutils literal notranslate"><span class="pre">match()</span></code>,
and other functions that accept a pattern for searching.</p>
<div class="section" id="case-insensitive-matching">
<h3>Case-insensitive Matching<a class="headerlink" href="#case-insensitive-matching" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">IGNORECASE</span></code> causes literal characters and character ranges in
the pattern to match both uppercase and lowercase characters.</p>
<div class="literal-block-wrapper docutils container" id="id28">
<div class="code-block-caption"><span class="caption-text">re_flags_ignorecase.py</span><a class="headerlink" href="#id28" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;This is some text -- with punctuation.&#39;</span>
<span class="n">pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\bT\w+&#39;</span>
<span class="n">with_case</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
<span class="n">without_case</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Text:</span><span class="se">\n</span><span class="s1">  </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">text</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Pattern:</span><span class="se">\n</span><span class="s1">  </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pattern</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Case-sensitive:&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">with_case</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">match</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Case-insensitive:&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">without_case</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">match</span><span class="p">))</span>
</pre></div>
</div>
</div>
<p>Since the pattern includes the literal <code class="docutils literal notranslate"><span class="pre">T</span></code>, if <code class="docutils literal notranslate"><span class="pre">IGNORECASE</span></code> is not
set, the only match is the word <code class="docutils literal notranslate"><span class="pre">This</span></code>.  When case is ignored,
<code class="docutils literal notranslate"><span class="pre">text</span></code> also matches.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_flags_ignorecase.py

Text:
  &#39;This is some text -- with punctuation.&#39;
Pattern:
  \bT\w+
Case-sensitive:
  &#39;This&#39;
Case-insensitive:
  &#39;This&#39;
  &#39;text&#39;
</pre></div>
</div>
</div>
<div class="section" id="input-with-multiple-lines">
<h3>Input with Multiple Lines<a class="headerlink" href="#input-with-multiple-lines" title="Permalink to this headline">¶</a></h3>
<p>Two flags affect how searching in multi-line input
works: <code class="docutils literal notranslate"><span class="pre">MULTILINE</span></code> and <code class="docutils literal notranslate"><span class="pre">DOTALL</span></code>.  The <code class="docutils literal notranslate"><span class="pre">MULTILINE</span></code>
flag controls how the pattern matching code processes anchoring
instructions for text containing newline characters.  When multiline
mode is turned on, the anchor rules for <code class="docutils literal notranslate"><span class="pre">^</span></code> and <code class="docutils literal notranslate"><span class="pre">$</span></code> apply at the
beginning and end of each line, in addition to the entire string.</p>
<div class="literal-block-wrapper docutils container" id="id29">
<div class="code-block-caption"><span class="caption-text">re_flags_multiline.py</span><a class="headerlink" href="#id29" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;This is some text -- with punctuation.</span><span class="se">\n</span><span class="s1">A second line.&#39;</span>
<span class="n">pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;(^\w+)|(\w+\S*$)&#39;</span>
<span class="n">single_line</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
<span class="n">multiline</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Text:</span><span class="se">\n</span><span class="s1">  </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">text</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Pattern:</span><span class="se">\n</span><span class="s1">  </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pattern</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Single Line :&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">single_line</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">match</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Multline    :&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">multiline</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">match</span><span class="p">))</span>
</pre></div>
</div>
</div>
<p>The pattern in the example matches the first or last word of the
input.  It matches <code class="docutils literal notranslate"><span class="pre">line.</span></code> at the end of the string, even though
there is no newline.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_flags_multiline.py

Text:
  &#39;This is some text -- with punctuation.\nA second line.&#39;
Pattern:
  (^\w+)|(\w+\S*$)
Single Line :
  (&#39;This&#39;, &#39;&#39;)
  (&#39;&#39;, &#39;line.&#39;)
Multline    :
  (&#39;This&#39;, &#39;&#39;)
  (&#39;&#39;, &#39;punctuation.&#39;)
  (&#39;A&#39;, &#39;&#39;)
  (&#39;&#39;, &#39;line.&#39;)
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">DOTALL</span></code> is the other flag related to multiline text.  Normally,
the dot character (<code class="docutils literal notranslate"><span class="pre">.</span></code>) matches everything in the input text except a
newline character.  The flag allows the dot to match newlines as well.</p>
<div class="literal-block-wrapper docutils container" id="id30">
<div class="code-block-caption"><span class="caption-text">re_flags_dotall.py</span><a class="headerlink" href="#id30" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;This is some text -- with punctuation.</span><span class="se">\n</span><span class="s1">A second line.&#39;</span>
<span class="n">pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;.+&#39;</span>
<span class="n">no_newlines</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
<span class="n">dotall</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Text:</span><span class="se">\n</span><span class="s1">  </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">text</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Pattern:</span><span class="se">\n</span><span class="s1">  </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pattern</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No newlines :&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">no_newlines</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">match</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Dotall      :&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">dotall</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">match</span><span class="p">))</span>
</pre></div>
</div>
</div>
<p>Without the flag, each line of the input text matches the pattern
separately.  Adding the flag causes the entire string to be consumed.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_flags_dotall.py

Text:
  &#39;This is some text -- with punctuation.\nA second line.&#39;
Pattern:
  .+
No newlines :
  &#39;This is some text -- with punctuation.&#39;
  &#39;A second line.&#39;
Dotall      :
  &#39;This is some text -- with punctuation.\nA second line.&#39;
</pre></div>
</div>
</div>
<div class="section" id="unicode">
<h3>Unicode<a class="headerlink" href="#unicode" title="Permalink to this headline">¶</a></h3>
<p>Under Python 3, <code class="docutils literal notranslate"><span class="pre">str</span></code> objects use the full Unicode character
set, and regular expression processing on a <code class="docutils literal notranslate"><span class="pre">str</span></code> assumes that the
pattern and input text are both Unicode.  The escape codes described
earlier are defined in terms of Unicode by default.  Those assumptions
mean that the pattern <code class="docutils literal notranslate"><span class="pre">\w+</span></code> will match both the words “French” and
“Français”. To restrict escape codes to the ASCII character set, as
was the default in Python 2, use the <code class="docutils literal notranslate"><span class="pre">ASCII</span></code> flag when
compiling the pattern or when calling the module-level functions
<code class="docutils literal notranslate"><span class="pre">search()</span></code> and <code class="docutils literal notranslate"><span class="pre">match()</span></code>.</p>
<div class="literal-block-wrapper docutils container" id="id31">
<div class="code-block-caption"><span class="caption-text">re_flags_ascii.py</span><a class="headerlink" href="#id31" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="n">text</span> <span class="o">=</span> <span class="sa">u</span><span class="s1">&#39;Français złoty Österreich&#39;</span>
<span class="n">pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\w+&#39;</span>
<span class="n">ascii_pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">ASCII</span><span class="p">)</span>
<span class="n">unicode_pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Text    :&#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Pattern :&#39;</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ASCII   :&#39;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">ascii_pattern</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">text</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Unicode :&#39;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">unicode_pattern</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">text</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<p>The other escape sequences (<code class="docutils literal notranslate"><span class="pre">\W</span></code>, <code class="docutils literal notranslate"><span class="pre">\b</span></code>, <code class="docutils literal notranslate"><span class="pre">\B</span></code>, <code class="docutils literal notranslate"><span class="pre">\d</span></code>, <code class="docutils literal notranslate"><span class="pre">\D</span></code>,
<code class="docutils literal notranslate"><span class="pre">\s</span></code>, and <code class="docutils literal notranslate"><span class="pre">\S</span></code>) are also processed differently for ASCII text.
Instead of consulting the Unicode database to find the properties of
each character, <code class="docutils literal notranslate"><span class="pre">re</span></code> uses the ASCII definition of the character set.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_flags_ascii.py

Text    : Français złoty Österreich
Pattern : \w+
ASCII   : [&#39;Fran&#39;, &#39;ais&#39;, &#39;z&#39;, &#39;oty&#39;, &#39;sterreich&#39;]
Unicode : [&#39;Français&#39;, &#39;złoty&#39;, &#39;Österreich&#39;]
</pre></div>
</div>
</div>
<div class="section" id="verbose-expression-syntax">
<h3>Verbose Expression Syntax<a class="headerlink" href="#verbose-expression-syntax" title="Permalink to this headline">¶</a></h3>
<p>The compact format of regular expression syntax can become a hindrance
as expressions grow more complicated.  As the number of groups in an
expression increases, it will be more work to keep track of why each
element is needed and how exactly the parts of the expression
interact.  Using named groups helps mitigate these issues, but a
better solution is to use <em>verbose mode</em> expressions, which allow
comments and extra whitespace to be embedded in the pattern.</p>
<p>A pattern to validate email addresses will illustrate how verbose mode
makes working with regular expressions easier.  The first version
recognizes addresses that end in one of three top-level domains:
<code class="docutils literal notranslate"><span class="pre">.com</span></code>, <code class="docutils literal notranslate"><span class="pre">.org</span></code>, or <code class="docutils literal notranslate"><span class="pre">.edu</span></code>.</p>
<div class="literal-block-wrapper docutils container" id="id32">
<div class="code-block-caption"><span class="caption-text">re_email_compact.py</span><a class="headerlink" href="#id32" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="n">address</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;[\w\d.+-]+@([\w\d.]+\.)+(com|org|edu)&#39;</span><span class="p">)</span>

<span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span>
    <span class="sa">u</span><span class="s1">&#39;first.last@example.com&#39;</span><span class="p">,</span>
    <span class="sa">u</span><span class="s1">&#39;first.last+category@gmail.com&#39;</span><span class="p">,</span>
    <span class="sa">u</span><span class="s1">&#39;valid-address@mail.example.com&#39;</span><span class="p">,</span>
    <span class="sa">u</span><span class="s1">&#39;not-valid@example.foo&#39;</span><span class="p">,</span>
<span class="p">]</span>

<span class="k">for</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
    <span class="n">match</span> <span class="o">=</span> <span class="n">address</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:&lt;30}</span><span class="s1">  </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">candidate</span><span class="p">,</span> <span class="s1">&#39;Matches&#39;</span> <span class="k">if</span> <span class="n">match</span> <span class="k">else</span> <span class="s1">&#39;No match&#39;</span><span class="p">)</span>
    <span class="p">)</span>
</pre></div>
</div>
</div>
<p>This expression is already complex.  There are several character
classes, groups, and repetition expressions.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_email_compact.py

first.last@example.com          Matches
first.last+category@gmail.com   Matches
valid-address@mail.example.com  Matches
not-valid@example.foo           No match
</pre></div>
</div>
<p>Converting the expression to a more verbose format will make it easier
to extend.</p>
<div class="literal-block-wrapper docutils container" id="id33">
<div class="code-block-caption"><span class="caption-text">re_email_verbose.py</span><a class="headerlink" href="#id33" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="n">address</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    [\w\d.+-]+       # username</span>
<span class="sd">    @</span>
<span class="sd">    ([\w\d.]+\.)+    # domain name prefix</span>
<span class="sd">    (com|org|edu)    # TODO: support more top-level domains</span>
<span class="sd">    &#39;&#39;&#39;</span><span class="p">,</span>
    <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">)</span>

<span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span>
    <span class="sa">u</span><span class="s1">&#39;first.last@example.com&#39;</span><span class="p">,</span>
    <span class="sa">u</span><span class="s1">&#39;first.last+category@gmail.com&#39;</span><span class="p">,</span>
    <span class="sa">u</span><span class="s1">&#39;valid-address@mail.example.com&#39;</span><span class="p">,</span>
    <span class="sa">u</span><span class="s1">&#39;not-valid@example.foo&#39;</span><span class="p">,</span>
<span class="p">]</span>

<span class="k">for</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
    <span class="n">match</span> <span class="o">=</span> <span class="n">address</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:&lt;30}</span><span class="s1">  </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">candidate</span><span class="p">,</span> <span class="s1">&#39;Matches&#39;</span> <span class="k">if</span> <span class="n">match</span> <span class="k">else</span> <span class="s1">&#39;No match&#39;</span><span class="p">),</span>
    <span class="p">)</span>
</pre></div>
</div>
</div>
<p>The expression matches the same inputs, but in this extended format it
is easier to read.  The comments also help identify different parts of
the pattern so that it can be expanded to match more inputs.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_email_verbose.py

first.last@example.com          Matches
first.last+category@gmail.com   Matches
valid-address@mail.example.com  Matches
not-valid@example.foo           No match
</pre></div>
</div>
<p>This expanded version parses inputs that include a person’s name and
email address, as might appear in an email header.  The name comes
first and stands on its own, and the email address follows, surrounded
by angle brackets (<code class="docutils literal notranslate"><span class="pre">&lt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>).</p>
<div class="literal-block-wrapper docutils container" id="id34">
<div class="code-block-caption"><span class="caption-text">re_email_with_name.py</span><a class="headerlink" href="#id34" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="n">address</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
    <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    # A name is made up of letters, and may include &quot;.&quot;</span>
<span class="sd">    # for title abbreviations and middle initials.</span>
<span class="sd">    ((?P&lt;name&gt;</span>
<span class="sd">       ([\w.,]+\s+)*[\w.,]+)</span>
<span class="sd">       \s*</span>
<span class="sd">       # Email addresses are wrapped in angle</span>
<span class="sd">       # brackets &lt; &gt;, but only if a name is</span>
<span class="sd">       # found, so keep the start bracket in this</span>
<span class="sd">       # group.</span>
<span class="sd">       &lt;</span>
<span class="sd">    )? # the entire name is optional</span>

<span class="sd">    # The address itself: username@domain.tld</span>
<span class="sd">    (?P&lt;email&gt;</span>
<span class="sd">      [\w\d.+-]+       # username</span>
<span class="sd">      @</span>
<span class="sd">      ([\w\d.]+\.)+    # domain name prefix</span>
<span class="sd">      (com|org|edu)    # limit the allowed top-level domains</span>
<span class="sd">    )</span>

<span class="sd">    &gt;? # optional closing angle bracket</span>
<span class="sd">    &#39;&#39;&#39;</span><span class="p">,</span>
    <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">)</span>

<span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span>
    <span class="sa">u</span><span class="s1">&#39;first.last@example.com&#39;</span><span class="p">,</span>
    <span class="sa">u</span><span class="s1">&#39;first.last+category@gmail.com&#39;</span><span class="p">,</span>
    <span class="sa">u</span><span class="s1">&#39;valid-address@mail.example.com&#39;</span><span class="p">,</span>
    <span class="sa">u</span><span class="s1">&#39;not-valid@example.foo&#39;</span><span class="p">,</span>
    <span class="sa">u</span><span class="s1">&#39;First Last &lt;first.last@example.com&gt;&#39;</span><span class="p">,</span>
    <span class="sa">u</span><span class="s1">&#39;No Brackets first.last@example.com&#39;</span><span class="p">,</span>
    <span class="sa">u</span><span class="s1">&#39;First Last&#39;</span><span class="p">,</span>
    <span class="sa">u</span><span class="s1">&#39;First Middle Last &lt;first.last@example.com&gt;&#39;</span><span class="p">,</span>
    <span class="sa">u</span><span class="s1">&#39;First M. Last &lt;first.last@example.com&gt;&#39;</span><span class="p">,</span>
    <span class="sa">u</span><span class="s1">&#39;&lt;first.last@example.com&gt;&#39;</span><span class="p">,</span>
<span class="p">]</span>

<span class="k">for</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Candidate:&#39;</span><span class="p">,</span> <span class="n">candidate</span><span class="p">)</span>
    <span class="n">match</span> <span class="o">=</span> <span class="n">address</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  Name :&#39;</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  Email:&#39;</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()[</span><span class="s1">&#39;email&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  No match&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>As with other programming languages, the ability to insert comments
into verbose regular expressions helps with their maintainability.
This final version includes implementation notes to future maintainers
and whitespace to separate the groups from each other and highlight
their nesting level.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_email_with_name.py

Candidate: first.last@example.com
  Name : None
  Email: first.last@example.com
Candidate: first.last+category@gmail.com
  Name : None
  Email: first.last+category@gmail.com
Candidate: valid-address@mail.example.com
  Name : None
  Email: valid-address@mail.example.com
Candidate: not-valid@example.foo
  No match
Candidate: First Last &lt;first.last@example.com&gt;
  Name : First Last
  Email: first.last@example.com
Candidate: No Brackets first.last@example.com
  Name : None
  Email: first.last@example.com
Candidate: First Last
  No match
Candidate: First Middle Last &lt;first.last@example.com&gt;
  Name : First Middle Last
  Email: first.last@example.com
Candidate: First M. Last &lt;first.last@example.com&gt;
  Name : First M. Last
  Email: first.last@example.com
Candidate: &lt;first.last@example.com&gt;
  Name : None
  Email: first.last@example.com
</pre></div>
</div>
</div>
<div class="section" id="embedding-flags-in-patterns">
<h3>Embedding Flags in Patterns<a class="headerlink" href="#embedding-flags-in-patterns" title="Permalink to this headline">¶</a></h3>
<p>In situations where flags cannot be added when compiling an
expression, such as when a pattern is passed as an argument to a
library function that will compile it later, the flags can be embedded
inside the expression string itself.  For example, to turn
case-insensitive matching on, add <code class="docutils literal notranslate"><span class="pre">(?i)</span></code> to the beginning of the
expression.</p>
<div class="literal-block-wrapper docutils container" id="id35">
<div class="code-block-caption"><span class="caption-text">re_flags_embedded.py</span><a class="headerlink" href="#id35" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;This is some text -- with punctuation.&#39;</span>
<span class="n">pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;(?i)\bT\w+&#39;</span>
<span class="n">regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Text      :&#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Pattern   :&#39;</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Matches   :&#39;</span><span class="p">,</span> <span class="n">regex</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">text</span><span class="p">))</span>
</pre></div>
</div>
</div>
<p>Because the options control the way the entire expression is evaluated
or parsed, they should always appear at the beginning of the expression.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_flags_embedded.py

Text      : This is some text -- with punctuation.
Pattern   : (?i)\bT\w+
Matches   : [&#39;This&#39;, &#39;text&#39;]
</pre></div>
</div>
<p>The abbreviations for all of the flags are listed in the table below.</p>
<table border="1" class="docutils" id="id36">
<caption><span class="caption-text">Regular Expression Flag Abbreviations</span><a class="headerlink" href="#id36" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Flag</th>
<th class="head">Abbreviation</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">ASCII</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">a</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">IGNORECASE</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">i</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">MULTILINE</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">m</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">DOTALL</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">s</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">VERBOSE</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">x</span></code></td>
</tr>
</tbody>
</table>
<p>Embedded flags can be combined by placing them within the same group.
For example, <code class="docutils literal notranslate"><span class="pre">(?im)</span></code> turns on case-insensitive matching for
multiline strings.</p>
</div>
</div>
<div class="section" id="looking-ahead-or-behind">
<h2>Looking Ahead or Behind<a class="headerlink" href="#looking-ahead-or-behind" title="Permalink to this headline">¶</a></h2>
<p>In many cases, it is useful to match a part of a pattern
only if some other part will also match.  For example, in the email
parsing expression, the angle brackets were marked as optional.
Realistically, the brackets should be paired, and the expression
should match only if both are present, or neither is.  This modified
version of the expression uses a <em>positive look ahead</em> assertion to
match the pair.  The look ahead assertion syntax is <code class="docutils literal notranslate"><span class="pre">(?=pattern)</span></code>.</p>
<div class="literal-block-wrapper docutils container" id="id37">
<div class="code-block-caption"><span class="caption-text">re_look_ahead.py</span><a class="headerlink" href="#id37" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="n">address</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    # A name is made up of letters, and may include &quot;.&quot;</span>
<span class="sd">    # for title abbreviations and middle initials.</span>
<span class="sd">    ((?P&lt;name&gt;</span>
<span class="sd">       ([\w.,]+\s+)*[\w.,]+</span>
<span class="sd">     )</span>
<span class="sd">     \s+</span>
<span class="sd">    ) # name is no longer optional</span>

<span class="sd">    # LOOKAHEAD</span>
<span class="sd">    # Email addresses are wrapped in angle brackets, but only</span>
<span class="sd">    # if both are present or neither is.</span>
<span class="sd">    (?= (&lt;.*&gt;$)       # remainder wrapped in angle brackets</span>
<span class="sd">        |</span>
<span class="sd">        ([^&lt;].*[^&gt;]$) # remainder *not* wrapped in angle brackets</span>
<span class="sd">      )</span>

<span class="sd">    &lt;? # optional opening angle bracket</span>

<span class="sd">    # The address itself: username@domain.tld</span>
<span class="sd">    (?P&lt;email&gt;</span>
<span class="sd">      [\w\d.+-]+       # username</span>
<span class="sd">      @</span>
<span class="sd">      ([\w\d.]+\.)+    # domain name prefix</span>
<span class="sd">      (com|org|edu)    # limit the allowed top-level domains</span>
<span class="sd">    )</span>

<span class="sd">    &gt;? # optional closing angle bracket</span>
<span class="sd">    &#39;&#39;&#39;</span><span class="p">,</span>
    <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">)</span>

<span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span>
    <span class="sa">u</span><span class="s1">&#39;First Last &lt;first.last@example.com&gt;&#39;</span><span class="p">,</span>
    <span class="sa">u</span><span class="s1">&#39;No Brackets first.last@example.com&#39;</span><span class="p">,</span>
    <span class="sa">u</span><span class="s1">&#39;Open Bracket &lt;first.last@example.com&#39;</span><span class="p">,</span>
    <span class="sa">u</span><span class="s1">&#39;Close Bracket first.last@example.com&gt;&#39;</span><span class="p">,</span>
<span class="p">]</span>

<span class="k">for</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Candidate:&#39;</span><span class="p">,</span> <span class="n">candidate</span><span class="p">)</span>
    <span class="n">match</span> <span class="o">=</span> <span class="n">address</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  Name :&#39;</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  Email:&#39;</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()[</span><span class="s1">&#39;email&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  No match&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>There are several important changes in this version of the expression.
First, the name portion is no longer optional.  That means stand-alone
addresses do not match, but it also prevents improperly formatted
name/address combinations from matching.  The positive look ahead rule
after the “name” group asserts that either the remainder of the string
is wrapped with a pair of angle brackets, or there is not a mismatched
bracket; either both of or neither of the brackets is present.  The look
ahead is expressed as a group, but the match for a look ahead group
does not consume any of the input text, so the rest of the pattern
picks up from the same spot after the look ahead matches.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_look_ahead.py

Candidate: First Last &lt;first.last@example.com&gt;
  Name : First Last
  Email: first.last@example.com
Candidate: No Brackets first.last@example.com
  Name : No Brackets
  Email: first.last@example.com
Candidate: Open Bracket &lt;first.last@example.com
  No match
Candidate: Close Bracket first.last@example.com&gt;
  No match
</pre></div>
</div>
<p>A <em>negative look ahead</em> assertion (<code class="docutils literal notranslate"><span class="pre">(?!pattern)</span></code>) says that the
pattern does not match the text following the current point.  For
example, the email recognition pattern could be modified to ignore
the <code class="docutils literal notranslate"><span class="pre">noreply</span></code> mailing addresses commonly used by automated systems.</p>
<div class="literal-block-wrapper docutils container" id="id38">
<div class="code-block-caption"><span class="caption-text">re_negative_look_ahead.py</span><a class="headerlink" href="#id38" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="n">address</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    ^</span>

<span class="sd">    # An address: username@domain.tld</span>

<span class="sd">    # Ignore noreply addresses</span>
<span class="sd">    (?!noreply@.*$)</span>

<span class="sd">    [\w\d.+-]+       # username</span>
<span class="sd">    @</span>
<span class="sd">    ([\w\d.]+\.)+    # domain name prefix</span>
<span class="sd">    (com|org|edu)    # limit the allowed top-level domains</span>

<span class="sd">    $</span>
<span class="sd">    &#39;&#39;&#39;</span><span class="p">,</span>
    <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">)</span>

<span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span>
    <span class="sa">u</span><span class="s1">&#39;first.last@example.com&#39;</span><span class="p">,</span>
    <span class="sa">u</span><span class="s1">&#39;noreply@example.com&#39;</span><span class="p">,</span>
<span class="p">]</span>

<span class="k">for</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Candidate:&#39;</span><span class="p">,</span> <span class="n">candidate</span><span class="p">)</span>
    <span class="n">match</span> <span class="o">=</span> <span class="n">address</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  Match:&#39;</span><span class="p">,</span> <span class="n">candidate</span><span class="p">[</span><span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">():</span><span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  No match&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>The address starting with <code class="docutils literal notranslate"><span class="pre">noreply</span></code> does not match the pattern,
since the look ahead assertion fails.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_negative_look_ahead.py

Candidate: first.last@example.com
  Match: first.last@example.com
Candidate: noreply@example.com
  No match
</pre></div>
</div>
<p>Instead of looking ahead for <code class="docutils literal notranslate"><span class="pre">noreply</span></code> in the username portion of
the email address, the pattern can alternatively be written using a <em>negative
look behind</em> assertion after the username is matched using the syntax
<code class="docutils literal notranslate"><span class="pre">(?&lt;!pattern)</span></code>.</p>
<div class="literal-block-wrapper docutils container" id="id39">
<div class="code-block-caption"><span class="caption-text">re_negative_look_behind.py</span><a class="headerlink" href="#id39" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="n">address</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    ^</span>

<span class="sd">    # An address: username@domain.tld</span>

<span class="sd">    [\w\d.+-]+       # username</span>

<span class="sd">    # Ignore noreply addresses</span>
<span class="sd">    (?&lt;!noreply)</span>

<span class="sd">    @</span>
<span class="sd">    ([\w\d.]+\.)+    # domain name prefix</span>
<span class="sd">    (com|org|edu)    # limit the allowed top-level domains</span>

<span class="sd">    $</span>
<span class="sd">    &#39;&#39;&#39;</span><span class="p">,</span>
    <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">)</span>

<span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span>
    <span class="sa">u</span><span class="s1">&#39;first.last@example.com&#39;</span><span class="p">,</span>
    <span class="sa">u</span><span class="s1">&#39;noreply@example.com&#39;</span><span class="p">,</span>
<span class="p">]</span>

<span class="k">for</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Candidate:&#39;</span><span class="p">,</span> <span class="n">candidate</span><span class="p">)</span>
    <span class="n">match</span> <span class="o">=</span> <span class="n">address</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  Match:&#39;</span><span class="p">,</span> <span class="n">candidate</span><span class="p">[</span><span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">():</span><span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  No match&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>Looking backward works a little differently than looking ahead, in
that the expression must use a fixed-length pattern.  Repetitions are
allowed, as long as there is a fixed number of them (no wildcards or ranges).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_negative_look_behind.py

Candidate: first.last@example.com
  Match: first.last@example.com
Candidate: noreply@example.com
  No match
</pre></div>
</div>
<p>A <em>positive look behind</em> assertion can be used to find text following
a pattern using the syntax <code class="docutils literal notranslate"><span class="pre">(?&lt;=pattern)</span></code>.  In the following example, the
expression finds Twitter handles.</p>
<div class="literal-block-wrapper docutils container" id="id40">
<div class="code-block-caption"><span class="caption-text">re_look_behind.py</span><a class="headerlink" href="#id40" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="n">twitter</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    # A twitter handle: @username</span>
<span class="sd">    (?&lt;=@)</span>
<span class="sd">    ([\w\d_]+)       # username</span>
<span class="sd">    &#39;&#39;&#39;</span><span class="p">,</span>
    <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">)</span>

<span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;This text includes two Twitter handles.</span>
<span class="s1">One for @ThePSF, and one for the author, @doughellmann.</span>
<span class="s1">&#39;&#39;&#39;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
<span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">twitter</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Handle:&#39;</span><span class="p">,</span> <span class="n">match</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>The pattern matches sequences of characters that can make up a Twitter
handle, as long as they are preceded by an <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_look_behind.py

This text includes two Twitter handles.
One for @ThePSF, and one for the author, @doughellmann.

Handle: ThePSF
Handle: doughellmann
</pre></div>
</div>
</div>
<div class="section" id="self-referencing-expressions">
<h2>Self-referencing Expressions<a class="headerlink" href="#self-referencing-expressions" title="Permalink to this headline">¶</a></h2>
<p>Matched values can be used in later parts of an expression.  For
example, the email example can be updated to match only addresses
composed of the first and last names of the person by including
back-references to those groups.  The easiest way to achieve this is
by referring to the previously matched group by ID number, using
<code class="docutils literal notranslate"><span class="pre">\num</span></code>.</p>
<div class="literal-block-wrapper docutils container" id="id41">
<div class="code-block-caption"><span class="caption-text">re_refer_to_group.py</span><a class="headerlink" href="#id41" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="n">address</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    # The regular name</span>
<span class="sd">    (\w+)               # first name</span>
<span class="sd">    \s+</span>
<span class="sd">    (([\w.]+)\s+)?      # optional middle name or initial</span>
<span class="sd">    (\w+)               # last name</span>

<span class="sd">    \s+</span>

<span class="sd">    &lt;</span>

<span class="sd">    # The address: first_name.last_name@domain.tld</span>
<span class="sd">    (?P&lt;email&gt;</span>
<span class="sd">      \1               # first name</span>
<span class="sd">      \.</span>
<span class="sd">      \4               # last name</span>
<span class="sd">      @</span>
<span class="sd">      ([\w\d.]+\.)+    # domain name prefix</span>
<span class="sd">      (com|org|edu)    # limit the allowed top-level domains</span>
<span class="sd">    )</span>

<span class="sd">    &gt;</span>
<span class="sd">    &#39;&#39;&#39;</span><span class="p">,</span>
    <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>

<span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span>
    <span class="sa">u</span><span class="s1">&#39;First Last &lt;first.last@example.com&gt;&#39;</span><span class="p">,</span>
    <span class="sa">u</span><span class="s1">&#39;Different Name &lt;first.last@example.com&gt;&#39;</span><span class="p">,</span>
    <span class="sa">u</span><span class="s1">&#39;First Middle Last &lt;first.last@example.com&gt;&#39;</span><span class="p">,</span>
    <span class="sa">u</span><span class="s1">&#39;First M. Last &lt;first.last@example.com&gt;&#39;</span><span class="p">,</span>
<span class="p">]</span>

<span class="k">for</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Candidate:&#39;</span><span class="p">,</span> <span class="n">candidate</span><span class="p">)</span>
    <span class="n">match</span> <span class="o">=</span> <span class="n">address</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  Match name :&#39;</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  Match email:&#39;</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  No match&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>Although the syntax is simple, creating back-references by numerical
ID has a few disadvantages.  From a practical standpoint, as the
expression changes, the groups must be counted again and every
reference may need to be updated.  Another disadvantage is that only
99 references can be made using the standard back-reference syntax
<code class="docutils literal notranslate"><span class="pre">\n</span></code>, because if the ID number is three digits long, it will be
interpreted as an octal character value instead of a group
reference.  Of course, if there are more than 99 groups in an
expression, there will be more serious maintenance challenges than simply not
being able to refer to all of them.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_refer_to_group.py

Candidate: First Last &lt;first.last@example.com&gt;
  Match name : First Last
  Match email: first.last@example.com
Candidate: Different Name &lt;first.last@example.com&gt;
  No match
Candidate: First Middle Last &lt;first.last@example.com&gt;
  Match name : First Last
  Match email: first.last@example.com
Candidate: First M. Last &lt;first.last@example.com&gt;
  Match name : First Last
  Match email: first.last@example.com
</pre></div>
</div>
<p>Python’s expression parser includes an extension that uses
<code class="docutils literal notranslate"><span class="pre">(?P=name)</span></code> to refer to the value of a named group matched earlier
in the expression.</p>
<div class="literal-block-wrapper docutils container" id="id42">
<div class="code-block-caption"><span class="caption-text">re_refer_to_named_group.py</span><a class="headerlink" href="#id42" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="n">address</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
    <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    # The regular name</span>
<span class="sd">    (?P&lt;first_name&gt;\w+)</span>
<span class="sd">    \s+</span>
<span class="sd">    (([\w.]+)\s+)?      # optional middle name or initial</span>
<span class="sd">    (?P&lt;last_name&gt;\w+)</span>

<span class="sd">    \s+</span>

<span class="sd">    &lt;</span>

<span class="sd">    # The address: first_name.last_name@domain.tld</span>
<span class="sd">    (?P&lt;email&gt;</span>
<span class="sd">      (?P=first_name)</span>
<span class="sd">      \.</span>
<span class="sd">      (?P=last_name)</span>
<span class="sd">      @</span>
<span class="sd">      ([\w\d.]+\.)+    # domain name prefix</span>
<span class="sd">      (com|org|edu)    # limit the allowed top-level domains</span>
<span class="sd">    )</span>

<span class="sd">    &gt;</span>
<span class="sd">    &#39;&#39;&#39;</span><span class="p">,</span>
    <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>

<span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span>
    <span class="sa">u</span><span class="s1">&#39;First Last &lt;first.last@example.com&gt;&#39;</span><span class="p">,</span>
    <span class="sa">u</span><span class="s1">&#39;Different Name &lt;first.last@example.com&gt;&#39;</span><span class="p">,</span>
    <span class="sa">u</span><span class="s1">&#39;First Middle Last &lt;first.last@example.com&gt;&#39;</span><span class="p">,</span>
    <span class="sa">u</span><span class="s1">&#39;First M. Last &lt;first.last@example.com&gt;&#39;</span><span class="p">,</span>
<span class="p">]</span>

<span class="k">for</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Candidate:&#39;</span><span class="p">,</span> <span class="n">candidate</span><span class="p">)</span>
    <span class="n">match</span> <span class="o">=</span> <span class="n">address</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  Match name :&#39;</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()[</span><span class="s1">&#39;first_name&#39;</span><span class="p">],</span>
              <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()[</span><span class="s1">&#39;last_name&#39;</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  Match email:&#39;</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()[</span><span class="s1">&#39;email&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  No match&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>The address expression is compiled with the <code class="docutils literal notranslate"><span class="pre">IGNORECASE</span></code> flag
on, since proper names are normally capitalized but email addresses
are not.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_refer_to_named_group.py

Candidate: First Last &lt;first.last@example.com&gt;
  Match name : First Last
  Match email: first.last@example.com
Candidate: Different Name &lt;first.last@example.com&gt;
  No match
Candidate: First Middle Last &lt;first.last@example.com&gt;
  Match name : First Last
  Match email: first.last@example.com
Candidate: First M. Last &lt;first.last@example.com&gt;
  Match name : First Last
  Match email: first.last@example.com
</pre></div>
</div>
<p>The other mechanism for using back-references in expressions chooses a
different pattern based on whether a previous group matched.
The email pattern can be corrected so that the angle brackets are
required if a name is present, and not required if the email address is by
itself.  The syntax for testing whether if a group has matched is
<code class="docutils literal notranslate"><span class="pre">(?(id)yes-expression|no-expression)</span></code>, where <code class="docutils literal notranslate"><span class="pre">id</span></code> is the group
name or number, <code class="docutils literal notranslate"><span class="pre">yes-expression</span></code> is the pattern to use if the group
has a value, and <code class="docutils literal notranslate"><span class="pre">no-expression</span></code> is the pattern to use otherwise.</p>
<div class="literal-block-wrapper docutils container" id="id43">
<div class="code-block-caption"><span class="caption-text">re_id.py</span><a class="headerlink" href="#id43" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="n">address</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    ^</span>

<span class="sd">    # A name is made up of letters, and may include &quot;.&quot;</span>
<span class="sd">    # for title abbreviations and middle initials.</span>
<span class="sd">    (?P&lt;name&gt;</span>
<span class="sd">       ([\w.]+\s+)*[\w.]+</span>
<span class="sd">     )?</span>
<span class="sd">    \s*</span>

<span class="sd">    # Email addresses are wrapped in angle brackets, but</span>
<span class="sd">    # only if a name is found.</span>
<span class="sd">    (?(name)</span>
<span class="sd">      # remainder wrapped in angle brackets because</span>
<span class="sd">      # there is a name</span>
<span class="sd">      (?P&lt;brackets&gt;(?=(&lt;.*&gt;$)))</span>
<span class="sd">      |</span>
<span class="sd">      # remainder does not include angle brackets without name</span>
<span class="sd">      (?=([^&lt;].*[^&gt;]$))</span>
<span class="sd">     )</span>

<span class="sd">    # Look for a bracket only if the look-ahead assertion</span>
<span class="sd">    # found both of them.</span>
<span class="sd">    (?(brackets)&lt;|\s*)</span>

<span class="sd">    # The address itself: username@domain.tld</span>
<span class="sd">    (?P&lt;email&gt;</span>
<span class="sd">      [\w\d.+-]+       # username</span>
<span class="sd">      @</span>
<span class="sd">      ([\w\d.]+\.)+    # domain name prefix</span>
<span class="sd">      (com|org|edu)    # limit the allowed top-level domains</span>
<span class="sd">     )</span>

<span class="sd">    # Look for a bracket only if the look-ahead assertion</span>
<span class="sd">    # found both of them.</span>
<span class="sd">    (?(brackets)&gt;|\s*)</span>

<span class="sd">    $</span>
<span class="sd">    &#39;&#39;&#39;</span><span class="p">,</span>
    <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">)</span>

<span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span>
    <span class="sa">u</span><span class="s1">&#39;First Last &lt;first.last@example.com&gt;&#39;</span><span class="p">,</span>
    <span class="sa">u</span><span class="s1">&#39;No Brackets first.last@example.com&#39;</span><span class="p">,</span>
    <span class="sa">u</span><span class="s1">&#39;Open Bracket &lt;first.last@example.com&#39;</span><span class="p">,</span>
    <span class="sa">u</span><span class="s1">&#39;Close Bracket first.last@example.com&gt;&#39;</span><span class="p">,</span>
    <span class="sa">u</span><span class="s1">&#39;no.brackets@example.com&#39;</span><span class="p">,</span>
<span class="p">]</span>

<span class="k">for</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Candidate:&#39;</span><span class="p">,</span> <span class="n">candidate</span><span class="p">)</span>
    <span class="n">match</span> <span class="o">=</span> <span class="n">address</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  Match name :&#39;</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  Match email:&#39;</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()[</span><span class="s1">&#39;email&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  No match&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>This version of the email address parser uses two tests.  If the
<code class="docutils literal notranslate"><span class="pre">name</span></code> group matches, then the look ahead assertion requires both
angle brackets and sets up the <code class="docutils literal notranslate"><span class="pre">brackets</span></code> group.  If <code class="docutils literal notranslate"><span class="pre">name</span></code> is not
matched, the assertion requires the rest of the text to not have angle
brackets around it.  Later, if the <code class="docutils literal notranslate"><span class="pre">brackets</span></code> group is set, the
actual pattern matching code consumes the brackets in the input using
literal patterns; otherwise, it consumes any blank space.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_id.py

Candidate: First Last &lt;first.last@example.com&gt;
  Match name : First Last
  Match email: first.last@example.com
Candidate: No Brackets first.last@example.com
  No match
Candidate: Open Bracket &lt;first.last@example.com
  No match
Candidate: Close Bracket first.last@example.com&gt;
  No match
Candidate: no.brackets@example.com
  Match name : None
  Match email: no.brackets@example.com
</pre></div>
</div>
</div>
<div class="section" id="modifying-strings-with-patterns">
<h2>Modifying Strings with Patterns<a class="headerlink" href="#modifying-strings-with-patterns" title="Permalink to this headline">¶</a></h2>
<p>In addition to searching through text, <code class="docutils literal notranslate"><span class="pre">re</span></code> supports
modifying text using regular expressions as the search mechanism, and
the replacements can reference groups matched in the pattern as part of
the substitution text.  Use <code class="docutils literal notranslate"><span class="pre">sub()</span></code> to replace all occurrences of a
pattern with another string.</p>
<div class="literal-block-wrapper docutils container" id="id44">
<div class="code-block-caption"><span class="caption-text">re_sub.py</span><a class="headerlink" href="#id44" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="n">bold</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\*</span><span class="si">{2}</span><span class="s1">(.*?)\*</span><span class="si">{2}</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;Make this **bold**.  This **too**.&#39;</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Text:&#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Bold:&#39;</span><span class="p">,</span> <span class="n">bold</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;&lt;b&gt;\1&lt;/b&gt;&#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">))</span>
</pre></div>
</div>
</div>
<p>References to the text matched by the pattern can be inserted using
the <code class="docutils literal notranslate"><span class="pre">\num</span></code> syntax used for back-references.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_sub.py

Text: Make this **bold**.  This **too**.
Bold: Make this &lt;b&gt;bold&lt;/b&gt;.  This &lt;b&gt;too&lt;/b&gt;.
</pre></div>
</div>
<p>To use named groups in the substitution, use the syntax <code class="docutils literal notranslate"><span class="pre">\g&lt;name&gt;</span></code>.</p>
<div class="literal-block-wrapper docutils container" id="id45">
<div class="code-block-caption"><span class="caption-text">re_sub_named_groups.py</span><a class="headerlink" href="#id45" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="n">bold</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\*</span><span class="si">{2}</span><span class="s1">(?P&lt;bold_text&gt;.*?)\*</span><span class="si">{2}</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;Make this **bold**.  This **too**.&#39;</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Text:&#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Bold:&#39;</span><span class="p">,</span> <span class="n">bold</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;&lt;b&gt;\g&lt;bold_text&gt;&lt;/b&gt;&#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">))</span>
</pre></div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">\g&lt;name&gt;</span></code> syntax also works with numbered references, and using
it eliminates any ambiguity between group numbers and surrounding
literal digits.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_sub_named_groups.py

Text: Make this **bold**.  This **too**.
Bold: Make this &lt;b&gt;bold&lt;/b&gt;.  This &lt;b&gt;too&lt;/b&gt;.
</pre></div>
</div>
<p>Pass a value to <code class="docutils literal notranslate"><span class="pre">count</span></code> to limit the number of substitutions
performed.</p>
<div class="literal-block-wrapper docutils container" id="id46">
<div class="code-block-caption"><span class="caption-text">re_sub_count.py</span><a class="headerlink" href="#id46" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="n">bold</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\*</span><span class="si">{2}</span><span class="s1">(.*?)\*</span><span class="si">{2}</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;Make this **bold**.  This **too**.&#39;</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Text:&#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Bold:&#39;</span><span class="p">,</span> <span class="n">bold</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;&lt;b&gt;\1&lt;/b&gt;&#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
</div>
<p>Only the first substitution is made because <code class="docutils literal notranslate"><span class="pre">count</span></code> is <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_sub_count.py

Text: Make this **bold**.  This **too**.
Bold: Make this &lt;b&gt;bold&lt;/b&gt;.  This **too**.
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">subn()</span></code> works just like <code class="docutils literal notranslate"><span class="pre">sub()</span></code> except that it returns both
the modified string and the count of substitutions made.</p>
<div class="literal-block-wrapper docutils container" id="id47">
<div class="code-block-caption"><span class="caption-text">re_subn.py</span><a class="headerlink" href="#id47" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="n">bold</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\*</span><span class="si">{2}</span><span class="s1">(.*?)\*</span><span class="si">{2}</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;Make this **bold**.  This **too**.&#39;</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Text:&#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Bold:&#39;</span><span class="p">,</span> <span class="n">bold</span><span class="o">.</span><span class="n">subn</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;&lt;b&gt;\1&lt;/b&gt;&#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">))</span>
</pre></div>
</div>
</div>
<p>The search pattern matches twice in the example.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_subn.py

Text: Make this **bold**.  This **too**.
Bold: (&#39;Make this &lt;b&gt;bold&lt;/b&gt;.  This &lt;b&gt;too&lt;/b&gt;.&#39;, 2)
</pre></div>
</div>
</div>
<div class="section" id="splitting-with-patterns">
<h2>Splitting with Patterns<a class="headerlink" href="#splitting-with-patterns" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">str.split()</span></code> is one of the most frequently used methods for
breaking apart strings to parse them.  It supports only the use of literal
values as separators, though, and sometimes a regular expression is
necessary if the input is not consistently formatted.  For example,
many plain text markup languages define paragraph separators as two or
more newline (<code class="docutils literal notranslate"><span class="pre">\n</span></code>) characters.  In this case, <code class="docutils literal notranslate"><span class="pre">str.split()</span></code>
cannot be used because of the “or more” part of the definition.</p>
<p>A strategy for identifying paragraphs using <code class="docutils literal notranslate"><span class="pre">findall()</span></code> would use
a pattern like <code class="docutils literal notranslate"><span class="pre">(.+?)\n{2,}</span></code>.</p>
<div class="literal-block-wrapper docutils container" id="id48">
<div class="code-block-caption"><span class="caption-text">re_paragraphs_findall.py</span><a class="headerlink" href="#id48" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;Paragraph one</span>
<span class="s1">on two lines.</span>

<span class="s1">Paragraph two.</span>


<span class="s1">Paragraph three.&#39;&#39;&#39;</span>

<span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">para</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(.+?)\n{2,}&#39;</span><span class="p">,</span>
                                      <span class="n">text</span><span class="p">,</span>
                                      <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>
                           <span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">para</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>
</div>
</div>
<p>That pattern fails for paragraphs at the end of the input text, as
illustrated by the fact that “Paragraph three.” is not part of the
output.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_paragraphs_findall.py

0 &#39;Paragraph one\non two lines.&#39;

1 &#39;Paragraph two.&#39;
</pre></div>
</div>
<p>Extending the pattern to say that a paragraph ends with two or more
newlines or the end of input fixes the problem, but makes the pattern
more complicated.  Converting to <code class="docutils literal notranslate"><span class="pre">re.split()</span></code> instead of
<code class="docutils literal notranslate"><span class="pre">re.findall()</span></code> handles the boundary condition automatically and
keeps the pattern simpler.</p>
<div class="literal-block-wrapper docutils container" id="id49">
<div class="code-block-caption"><span class="caption-text">re_split.py</span><a class="headerlink" href="#id49" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;Paragraph one</span>
<span class="s1">on two lines.</span>

<span class="s1">Paragraph two.</span>


<span class="s1">Paragraph three.&#39;&#39;&#39;</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;With findall:&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">para</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(.+?)(\n{2,}|$)&#39;</span><span class="p">,</span>
                                      <span class="n">text</span><span class="p">,</span>
                                      <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">para</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">()</span>

<span class="nb">print</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;With split:&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">para</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\n{2,}&#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">)):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">para</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>
</div>
</div>
<p>The pattern argument to <code class="docutils literal notranslate"><span class="pre">split()</span></code> expresses the markup
specification more precisely. Two or more newline characters mark a
separator point between paragraphs in the input string.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_split.py

With findall:
0 (&#39;Paragraph one\non two lines.&#39;, &#39;\n\n&#39;)

1 (&#39;Paragraph two.&#39;, &#39;\n\n\n&#39;)

2 (&#39;Paragraph three.&#39;, &#39;&#39;)


With split:
0 &#39;Paragraph one\non two lines.&#39;

1 &#39;Paragraph two.&#39;

2 &#39;Paragraph three.&#39;
</pre></div>
</div>
<p>Enclosing the expression in parentheses to define a group causes
<code class="docutils literal notranslate"><span class="pre">split()</span></code> to work more like <code class="docutils literal notranslate"><span class="pre">str.partition()</span></code>, so it returns
the separator values as well as the other parts of the string.</p>
<div class="literal-block-wrapper docutils container" id="id50">
<div class="code-block-caption"><span class="caption-text">re_split_groups.py</span><a class="headerlink" href="#id50" title="Permalink to this code">¶</a></div>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;Paragraph one</span>
<span class="s1">on two lines.</span>

<span class="s1">Paragraph two.</span>


<span class="s1">Paragraph three.&#39;&#39;&#39;</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;With split:&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">para</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\n{2,})&#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">)):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">para</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>
</div>
</div>
<p>The output now includes each paragraph, as well as the sequence of
newlines separating them.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python3 re_split_groups.py

With split:
0 &#39;Paragraph one\non two lines.&#39;

1 &#39;\n\n&#39;

2 &#39;Paragraph two.&#39;

3 &#39;\n\n\n&#39;

4 &#39;Paragraph three.&#39;
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference external" href="https://docs.python.org/3.7/library/re.html">Standard library documentation for re</a></li>
<li><a class="reference external" href="https://docs.python.org/3.5/howto/regex.html">Regular Expression HOWTO</a> – Andrew
Kuchling’s introduction to regular expressions for Python
developers.</li>
<li><a class="reference external" href="http://kodos.sourceforge.net/">Kodos</a> – An interactive
regular expression testing tool by Phil Schwartz.</li>
<li><a class="reference external" href="http://pythex.org">pythex</a> – A web-based tool for testing
regular expressions created by Gabriel Rodríguez.  Inspired by
Rubular.</li>
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Regular_expressions">Wikipedia: Regular expression</a> – General
introduction to regular expression concepts and techniques.</li>
<li><a class="reference internal" href="../locale/index.html#module-locale" title="locale: POSIX cultural localization API"><code class="xref py py-mod docutils literal notranslate"><span class="pre">locale</span></code></a> – Use the <code class="docutils literal notranslate"><span class="pre">locale</span></code> module to set the language
configuration when working with Unicode text.</li>
<li><code class="xref py py-mod docutils literal notranslate"><span class="pre">unicodedata</span></code> – Programmatic access to the Unicode
character property database.</li>
</ul>
</div>
</div>
</div>



        <div id="footer-nav">
<a id="prev-link" href="../textwrap/index.html"
   title="previous chapter"><i class="fa fa-arrow-circle-left"></i> textwrap — Formatting Text Paragraphs</a>
<a id="next-link" href="../difflib/index.html"
   title="next chapter">difflib — Compare Sequences <i class="fa fa-arrow-circle-right"></i></a>
        </div>

        </div>
      </div>

      <div class="pure-u-1-4">
        <div class="sidebar-wrapper">
          <div class="sidebar">
<div id="sidebar-toc">
  <h5>Quick Links</h5>
  <ul>
    
    <li><a href="#finding-patterns-in-text"><i class="fa fa-caret-right"></i>Finding Patterns in Text</a></li>
    
    <li><a href="#compiling-expressions"><i class="fa fa-caret-right"></i>Compiling Expressions</a></li>
    
    <li><a href="#multiple-matches"><i class="fa fa-caret-right"></i>Multiple Matches</a></li>
    
    <li><a href="#pattern-syntax"><i class="fa fa-caret-right"></i>Pattern Syntax</a></li>
    
    <li><a href="#repetition"><i class="fa fa-caret-right"></i>Repetition</a></li>
    
    <li><a href="#character-sets"><i class="fa fa-caret-right"></i>Character Sets</a></li>
    
    <li><a href="#escape-codes"><i class="fa fa-caret-right"></i>Escape Codes</a></li>
    
    <li><a href="#anchoring"><i class="fa fa-caret-right"></i>Anchoring</a></li>
    
    <li><a href="#constraining-the-search"><i class="fa fa-caret-right"></i>Constraining the Search</a></li>
    
    <li><a href="#dissecting-matches-with-groups"><i class="fa fa-caret-right"></i>Dissecting Matches with Groups</a></li>
    
    <li><a href="#search-options"><i class="fa fa-caret-right"></i>Search Options</a></li>
    
    <li><a href="#case-insensitive-matching"><i class="fa fa-caret-right"></i>Case-insensitive Matching</a></li>
    
    <li><a href="#input-with-multiple-lines"><i class="fa fa-caret-right"></i>Input with Multiple Lines</a></li>
    
    <li><a href="#unicode"><i class="fa fa-caret-right"></i>Unicode</a></li>
    
    <li><a href="#verbose-expression-syntax"><i class="fa fa-caret-right"></i>Verbose Expression Syntax</a></li>
    
    <li><a href="#embedding-flags-in-patterns"><i class="fa fa-caret-right"></i>Embedding Flags in Patterns</a></li>
    
    <li><a href="#looking-ahead-or-behind"><i class="fa fa-caret-right"></i>Looking Ahead or Behind</a></li>
    
    <li><a href="#self-referencing-expressions"><i class="fa fa-caret-right"></i>Self-referencing Expressions</a></li>
    
    <li><a href="#modifying-strings-with-patterns"><i class="fa fa-caret-right"></i>Modifying Strings with Patterns</a></li>
    
    <li><a href="#splitting-with-patterns"><i class="fa fa-caret-right"></i>Splitting with Patterns</a></li>
    
  </ul>
</div>

          </div>
          <div class="sidebar"><div id="sidebar-last-updated">
  This page was last updated 2018-12-09.
</div>

          </div>
          <div class="sidebar">
<div id="sidebar-nav">
  <h5>Navigation</h5>
  <ul>
    <li><a href="../textwrap/index.html"
           title="previous chapter"><i class="fa fa-arrow-circle-left"></i>textwrap — Formatting Text Paragraphs</a></li>
    <li><a href="../difflib/index.html"
           title="next chapter"><i class="fa fa-arrow-circle-right"></i>difflib — Compare Sequences</a></li>
  </ul>
</div>
          </div>
          <div class="sidebar"><div id="sidebar-book"><a target="new" href="https://doughellmann.com/books/the-python-3-standard-library-by-example/"><img src="../_static/book-cover-image-med.jpg"><br>Get the book</a></div>
          </div>
          <div class="sidebar"><div id="sidebar-example-disclaimer">
<p>The output from all the example programs
from PyMOTW-3 has been generated with Python 3.7.9, unless
otherwise noted. Some of the features described here may not be
available in earlier versions of Python.</p>
<p>Looking for <a href="/2/">examples for Python 2</a>?</p>
</div>
          </div>

        </div>
      </div>

    </div>

    <div class="pure-g-r" id="footer">

      <div class="pure-u-1-3">
        <div class="footer-list">
            <h4>This Site</h4>
            <ul>
              <li><a href="../py-modindex.html"><i class="fa fa-list fa-lg"></i> Module Index</a></li>
              <li><a href="../genindex.html"><i class="fa fa-italic fa-lg"></i> Index</a></li>
            </ul>
        </div>
      </div><div class="pure-u-1-3">
          <div class="footer-content">
            <div class="socialmedia">
              <a class="sociallink" href="../index.html"
       title="Home">
      <i class="fa fa-home fa-lg"></i></a>
              <a class="sociallink" href="../about.html"
       title="About">
      <i class="fa fa-user fa-lg"></i></a>
              <a class="sociallink" href="http://www.twitter.com/pymotw"
       title="Twitter">
      <i class="fa fa-twitter fa-lg"></i></a>
              <a class="sociallink" href="https://feeds.feedburner.com/PyMOTW"
       title="Subscribe via RSS">
      <i class="fa fa-rss-square fa-lg"></i></a>
              <a class="sociallink" href="http://feedburner.google.com/fb/a/mailverify?uri=PyMOTW&amp;loc=en_US"
       title="Subscribe via Email">
      <i class="fa fa-envelope fa-lg"></i></a>
            </div>

            <div class="copyright">
              <a rel="author" href="../about.html">&copy; Copyright 2021, Doug Hellmann</a>
            </div>

            <div class="cc"><a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.en_US" rel="license"><img alt="Creative Commons License BY-NC-SA" style="border-width:0; align: center;" width="88" height="31" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFgAAAAfCAMAAABUFvrSAAAABGdBTUEAALGOfPtRkwAAAf5QTFRF////////////AAAADQwNDQ4NDg4OEBAQGRkZGxsbHxscICAgIx8gJCQkKCUmKCgoKCkoKSkpKSopKicnKioqLS0tMDAwMS0uMjExMjMxNTY1Pj8+Pzc5Pzs8QEBAQ0RDUFBQUFFQWldYXV5dYGBgY19haGVmbmxscHBwcHJvdXJzdnN0eHV2eXx5en15fH98fX98fnt8f4F+gICAgoWChIGChIWEhIaEh4aHiYyJjIqLjoeLj4+PkY+PkZORkZSRk5iTlZmUlpmWmJaXmpiZnp2dnqCdn5aan5+fn6Oeoqaho6Gho6ijpqqmq7GqrKurrLKrrbOsrrOtrrStr6+vr7Kvr7Sur7WusLOvsLWvsLavsbewsrexsrixs7iytLmztLqztbW1tbq0tru1t7y2uL23ub64ub65urm5ur+5ur+6u8C6u8C7vMC8vMG7vMG8vcK8vcK9vsK9vsO+v7+/v8O+v8S+wMS/wMW/wMXAwcXAwsfCw8fCw8jDxMfDxMjDxMnExcnExcnFxsrFxsrGx8vHyMfHyMzHyMzIycjIyc3Iyc3Jys3Jy8rLy87Ky8/Ky8/LzM/LzNDLzNDMzdDMzdHMzdHNztHNztLOz8/Pz9PP0NPP0NTQ0dTQ0dTR0tXR0tXS09bS1tXV39/f4N/g4+Pj6Ofn7+/v8fHx////rrSdFQAAAAN0Uk5TAAoO5yEBUwAAA+FJREFUSMe1lo9301QUx6uXUmaf0qJ26iTrRoVinUzjQNR1gAyH6Lqx6XTDoVvXbU7qhA5m7CgYWaTDlLa6AiFsba3t+y+9Sdr8OvVMi7zTnLTf5H7ee9/73n11PA1PpDkcADPRWPwKt8YLG2I2n89m7gh8iluJz0dnpqe+HBsdHRn+7w3JyF1cvpbk05mCJG8Xi9uPpMLdNJ9cXV5UyBNjoyMtkR2A3B9Tt8SCfLTTqUzC2XlMvpcRbnA/IPmryYnzoyM9XuWBt8eI21FBcAy5Qk4KtxkGtQ1I+fRNbnk+evHC5NhJDwATDDIAnhNa1ImdFQTHr6WEvNyFPFeATSTYgAu/dl3/I31jNR6bnZ76eDf4yxRb2Q+71aiz/0JB8JXkrZzCdbFVqrUhRHuu54XkytLczAUvBFADUB6ARwnyqEp/t02prK9XdAXBHC9KyPWVqd6qPhyzlOG55dhsL/hLDTD1A3rYAy+dRu6eXaGKruA75wi2hbqigNd+LYSRW6XUSh64l05dXYruA1OPZfAOD3vhObL/ILDvQkRXynSdvPpaiJB+TVHAfEZuA9d9amlVF7TJd3nu+xgwyu8AqNOnDGAM8/obOLhQpWQotPYReZ/SQdKuKQpY2DwKwFJbGwI4VhCSlxchSFUnNC+CCgaV9RAKoZKh1J4le9FmQv5SFQW88aATXGhEws8wrHb7AANc0CndQS+ag5ERaieke0FXvnkxoYL/1MGi7FSmmVBXMDOu3gLK5J2PMjdXv2tmBX6pDdKSkq39DWXh3G1KI4QYVmS3AHCIPnCXE+4hHy6PcfeQ6sV2lufiL2jJ0wasp4p2k/Z2CEXeeqahDBLS1/c8+dBIXq4IkFAiWQ1QtxtnUMz/wsXfBj+1LzdUKn17dvXXzEqfMoFDNWO57QCe22dskKB5g7zXbVN+i0RKumKxonrfzaIVys2wYu7TVrd0PXn1rOnJC4JTFjF5c19/gnXLFwj6jJJz1rOjoi63LnBRfbmNM+qNunG5baSufhu9OPX5my2VTWEzrHrRbIP8dHl+dnpyrIVDBME/q1u6/E9bGmt9i2AsQmeaFaFwIb22soSlfuL8SEtgOCJKB5BsKkNltWyK7zzWMY3X4exDc6GvsljoX5FzR+BxwdCbf3jAdjTJv5/S39H2B2iXpmgXpWB7iVrB0JuVzpgP07CUO2WKqX+oiVL/benKImhgOIzHf7hx/A/IBdHsQ6Nsmruilo4afVFqB8PLn2U2H8hbxeKWjH9YvuiwxNiMaNhALZptCg5d7zh+Sczmclnx0vEOax6ajdjucSMPTcD/97/Cp54Q929ZZbgcR3o0hAAAAABJRU5ErkJggg=="/></a>
            </div>

          </div></div><div class="pure-u-1-3">
          <div class="footer-list">
            <h4>Other Writing</h4>
            <ul>
              <li><a href="https://doughellmann.com/"><i class="fa fa-pencil fa-lg"></i> Blog</a></li>
              <li><a href="https://doughellmann.com/books/the-python-3-standard-library-by-example/"><i class="fa fa-book fa-lg"></i> The Python Standard Library By Example</a></li>
            </ul>
          </div>
        </div><script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-38546875-3', 'pymotw.com');
  ga('send', 'pageview');
</script>

  </body>
</html>